"""
Ø¨ÙˆØª ØªÙ„ÙŠØ¬Ø±Ø§Ù… 'Ù†Ø¨Ø±Ø§Ø³' - Ù…Ø¹Ù„Ù… Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ© - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© v3
====================================================================
Ø¨ÙˆØª Ù…ØªØ®ØµØµ ÙÙŠ ØªØ¹Ù„ÙŠÙ… ÙˆØ´Ø±Ø­ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù†Ø¨ÙˆÙŠØ© Ù…Ù† ÙƒØªØ§Ø¨ Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©
Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…Ø¹ Ù…ÙŠØ²Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ø¹Ù„Ù….

Ø§Ù„Ù…ÙŠØ²Ø§Øª (v3 â€” 10/10):
- ğŸ” Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« (Ù…Ø¹ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø¹Ù†ÙˆØ§Ù†)
- ğŸ“ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ØªÙØ§Ø¹Ù„ÙŠØ© (4 Ø£Ù†ÙˆØ§Ø¹ Ø£Ø³Ø¦Ù„Ø©)
- ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ØªÙ‚Ø¯Ù… Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© ÙˆØ¥Ø¬Ù…Ø§Ù„ÙŠØ©
- ğŸ”– Ø§Ù„Ù…ÙØ¶Ù„Ø©
- ğŸ”— Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© (Ø±ÙˆØ§Ø¨Ø· Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù…Ù† JSON)
- ğŸ“ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©
- ğŸ“… Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… (Ù…Ø¹ ØªØ°ÙƒÙŠØ± Ø°ÙƒÙŠ Ø¨Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ)
- ğŸ¯ Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ© Ù…Ù†Ø¸Ù…Ø©
- ğŸ’¬ Ø´Ø±Ø­ Ù…Ø¨Ø³Ø· ÙˆÙ…Ù‚Ø§Ø±Ù† (Ù…Ø¹ Ø°Ø§ÙƒØ±Ø© Ø³ÙŠØ§Ù‚ Ù…Ø­Ø³Ù‘Ù†Ø©)
- â° ØªØ°ÙƒÙŠØ± ÙŠÙˆÙ…ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ
- ğŸ’¡ Ø£Ø³Ø¦Ù„Ø© Ø°ÙƒÙŠØ© Ù…Ù‚ØªØ±Ø­Ø©
- â˜• Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ø¹Ù…
- ğŸ‘¤ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© (Ø¬Ø¯ÙŠØ¯)
- ğŸ·ï¸ Ø§Ù„ØªØµÙØ­ Ø¨Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª ÙˆØ§Ù„ØªØµÙ†ÙŠÙØ§Øª (Ø¬Ø¯ÙŠØ¯)
- ğŸŒ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (Ø¬Ø¯ÙŠØ¯)
- ğŸ… Ø´Ø§Ø±Ø© Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø¯Ø³ÙŠ (Ø¬Ø¯ÙŠØ¯)
- ğŸƒ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸ / Flashcards (Ø¬Ø¯ÙŠØ¯)
- ğŸ† Ù†Ø¸Ø§Ù… Ø§Ù„Ø´Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª (Ø¬Ø¯ÙŠØ¯)
- ğŸ”¥ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© / Streak (Ø¬Ø¯ÙŠØ¯)
- ğŸ¤” Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù (Ø¬Ø¯ÙŠØ¯)
- ğŸ“¤ Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø­Ø¯ÙŠØ« Ø¨ØµÙŠØºØ© Ø¬Ø§Ù‡Ø²Ø© (Ø¬Ø¯ÙŠØ¯)
- ğŸ”” ØªØ°ÙƒÙŠØ± Ø°ÙƒÙŠ Ø¨Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« ØºÙŠØ± Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø© (Ø¬Ø¯ÙŠØ¯)
- ğŸŒ™ ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ / ØªØ°ÙƒÙŠØ± Ù…Ø³Ø§Ø¦ÙŠ (Ø¬Ø¯ÙŠØ¯)
"""

import os
import logging
import asyncio
import json
import random
import re
from typing import Optional, Dict, List, Any, Tuple
from collections import deque
from pathlib import Path
from datetime import datetime, timedelta
from datetime import time as datetime_time
from zoneinfo import ZoneInfo

import httpx
from dotenv import load_dotenv
from telegram import Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)

load_dotenv()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ù„Ø«ÙˆØ§Ø¨Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TELEGRAM_TOKEN: Optional[str] = os.getenv("TELEGRAM_TOKEN")
GOOGLE_API_KEY: Optional[str] = os.getenv("GOOGLE_API_KEY")
OPENROUTER_API_KEY: Optional[str] = os.getenv("OPENROUTER_API_KEY")
DEVELOPER_TELEGRAM_ID: Optional[str] = os.getenv("DEVELOPER_TELEGRAM_ID")
# ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø© â€” ÙŠÙÙØ¹ÙÙ‘Ù„ Ø¨Ø£Ù…Ø± /admin_maintenance
_maintenance_mode: bool = False
_maintenance_message: str = "ğŸ”§ Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹."

SUPPORT_LINK = "https://ko-fi.com/nibras_hadith"
SUPPORT_REMINDER_INTERVAL = 30

# â”€â”€ Monetag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MONETAG_ENABLED:  bool = os.getenv("MONETAG_ENABLED", "True").strip().lower() == "true"
MONETAG_DIRECT_LINK: str = os.getenv("MONETAG_DIRECT_LINK", "https://omg10.com/4/10632325")
# Ø¹Ø±Ø¶ Ø¥Ø¹Ù„Ø§Ù† ÙƒÙ„ N ØªÙØ§Ø¹Ù„ (0 = Ù…Ø¹Ø·Ù‘Ù„)
MONETAG_INTERVAL: int  = 8
# ØªØªØ¨Ø¹ Ø¢Ø®Ø± Ù…Ø±Ø© Ø¸Ù‡Ø± ÙÙŠÙ‡Ø§ Ø¥Ø¹Ù„Ø§Ù† Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù… {user_id: interaction_count_at_last_ad}
_monetag_last_shown: Dict[int, int] = {}

DEFAULT_REMINDER_TIME = "08:00"
DEFAULT_TIMEZONE = "Asia/Riyadh"

MAX_CONVERSATION_HISTORY = 8
REQUEST_TIMEOUT = 30.0

HADITH_FILE_PATH = Path("nawawi40_structured.json")
USER_DATA_PATH = Path("user_data")
USER_DATA_PATH.mkdir(exist_ok=True)

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def validate_configuration() -> None:
    required = {"TELEGRAM_TOKEN": TELEGRAM_TOKEN, "OPENROUTER_API_KEY": OPENROUTER_API_KEY}
    missing = [k for k, v in required.items() if not v]
    if missing:
        msg = f"âŒ Ù…ØªØºÙŠØ±Ø§Øª Ø¨ÙŠØ¦ÙŠØ© Ù…ÙÙ‚ÙˆØ¯Ø©: {', '.join(missing)}"
        logger.error(msg)
        raise EnvironmentError(f"{msg}\nÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù .env ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©.")
    logger.info("âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« (Ù…Ø­Ø³Ù‘Ù†Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HadithDatabase:
    """Ø¥Ø¯Ø§Ø±Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« â€” ØªØ³ØªØ®Ø±Ø¬ ÙƒÙ„ Ø­Ù‚ÙˆÙ„ JSON Ø§Ù„Ø«Ø±ÙŠØ©"""

    def __init__(self, file_path: Path) -> None:
        self.file_path = file_path
        self.hadiths: List[Dict[str, Any]] = []
        self._index: Dict[int, Dict[str, Any]] = {}
        # ÙÙ‡Ø±Ø³ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª: category_arabic â†’ [hadith_ids]
        self._topics_index: Dict[str, List[int]] = {}
        # ÙÙ‡Ø±Ø³ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª Ø§Ù„ÙØ±Ø¯ÙŠØ©: topic â†’ [hadith_ids]
        self._topic_tags_index: Dict[str, List[int]] = {}
        self._load_data()

    def _load_data(self) -> None:
        if not self.file_path.exists():
            logger.warning(f"âš ï¸ Ù…Ù„Ù Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: {self.file_path}")
            return
        try:
            with open(self.file_path, "r", encoding="utf-8") as f:
                raw = json.load(f)
            for h in raw.get("hadiths", []):
                hadith = self._normalise(h)
                self.hadiths.append(hadith)
                self._index[hadith["id"]] = hadith
                # Ø¨Ù†Ø§Ø¡ ÙÙ‡Ø±Ø³ Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª
                cat = hadith.get("category_arabic", "")
                if cat:
                    self._topics_index.setdefault(cat, []).append(hadith["id"])
                # Ø¨Ù†Ø§Ø¡ ÙÙ‡Ø±Ø³ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª Ø§Ù„ÙØ±Ø¯ÙŠØ©
                for tag in hadith.get("topics_arabic", []):
                    self._topic_tags_index.setdefault(tag, []).append(hadith["id"])
            logger.info(f"âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ {len(self.hadiths)} Ø­Ø¯ÙŠØ« | {len(self._topics_index)} ØªØµÙ†ÙŠÙ")
        except json.JSONDecodeError as exc:
            logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ JSON: {exc}")
        except OSError as exc:
            logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©: {exc}")

    @staticmethod
    def _normalise(h: Dict[str, Any]) -> Dict[str, Any]:
        """ØªØ­ÙˆÙŠÙ„ Ø³Ø¬Ù„ Ø®Ø§Ù… Ø¥Ù„Ù‰ ØµÙŠØºØ© Ø¯Ø§Ø®Ù„ÙŠØ© Ù…ÙˆØ­Ù‘Ø¯Ø© â€” ÙŠØ³ØªØ®Ø±Ø¬ ÙƒÙ„ Ø§Ù„Ø­Ù‚ÙˆÙ„"""
        hid = h.get("idInBook", h.get("id"))

        # â”€â”€ Ø§Ù„Ø±Ø§ÙˆÙŠ â”€â”€
        narrator_raw = h.get("narrator", "")
        if isinstance(narrator_raw, dict):
            narrator_name = narrator_raw.get("arabic", "")
            narrator_full = narrator_raw  # Ù†Ø­ØªÙØ¸ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
        else:
            narrator_name = str(narrator_raw)
            narrator_full = {}

        # â”€â”€ Ø§Ù„Ù…ØµØ¯Ø± â”€â”€
        source_raw = h.get("source", {})
        if isinstance(source_raw, dict):
            source_text  = source_raw.get("grade_arabic", "Ø§Ù„Ø£Ø±Ø¨Ø¹ÙˆÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©")
            source_books = source_raw.get("books_arabic", [])
            source_grade = source_raw.get("grade_arabic", "")
        else:
            source_text  = str(source_raw) if source_raw else "Ø§Ù„Ø£Ø±Ø¨Ø¹ÙˆÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©"
            source_books = []
            source_grade = ""

        # â”€â”€ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª â”€â”€
        topics_raw = h.get("topics", {})
        if isinstance(topics_raw, dict):
            topics_arabic   = topics_raw.get("arabic", [])
            topics_english  = topics_raw.get("english", [])
            category_arabic = topics_raw.get("category_arabic", "")
        else:
            topics_arabic = topics_english = []
            category_arabic = ""

        # â”€â”€ Ù†ÙˆØ¹ Ø§Ù„Ø­Ø¯ÙŠØ« â”€â”€
        htype_raw = h.get("hadith_type", {})
        if isinstance(htype_raw, dict):
            hadith_type_key    = htype_raw.get("type", "marfu")
            hadith_type_arabic = htype_raw.get("arabic", "Ø­Ø¯ÙŠØ« Ù…Ø±ÙÙˆØ¹")
        else:
            hadith_type_key    = "marfu"
            hadith_type_arabic = "Ø­Ø¯ÙŠØ« Ù…Ø±ÙÙˆØ¹"

        # â”€â”€ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© â”€â”€
        english_raw = h.get("english", {})
        if isinstance(english_raw, dict):
            english_narrator = english_raw.get("narrator", "")
            english_text     = english_raw.get("text", "")
        else:
            english_narrator = english_text = ""

        return {
            "id":                   hid,
            "title":                h.get("arabic_title", f"Ø§Ù„Ø­Ø¯ÙŠØ« {hid}"),
            "narrator":             narrator_name,
            "narrator_full":        narrator_full,      # dict ÙƒØ§Ù…Ù„ Ù„Ù„Ø±Ø§ÙˆÙŠ
            "text":                 h.get("arabic", ""),
            "narrator_intro":       h.get("arabic_narrator_intro", ""),
            "hadith_text_only":     h.get("arabic_hadith_text", ""),
            "arabic_plain":         h.get("arabic_plain", ""),
            "source":               source_text,
            "source_books":         source_books,
            "source_grade":         source_grade,
            "vocabulary":           h.get("vocabulary", []),
            "benefits":             h.get("benefits", []),
            "topics_arabic":        topics_arabic,
            "topics_english":       topics_english,
            "category_arabic":      category_arabic,
            "hadith_type":          hadith_type_key,     # "marfu" Ø£Ùˆ "qudsi"
            "hadith_type_arabic":   hadith_type_arabic,
            "english_narrator":     english_narrator,
            "english_text":         english_text,
            "related_hadiths":      h.get("related_hadiths", []),  # â† Ø±ÙˆØ§Ø¨Ø· Ø­Ù‚ÙŠÙ‚ÙŠØ©!
        }

    @staticmethod
    def _extract_narrator(arabic_text: str) -> str:
        patterns = [
            r"^Ø¹ÙÙ†Ù’ (.+?)(?:\s+Ø±ÙØ¶ÙÙŠÙ|\s+Ù‚ÙØ§Ù„Ù|\s+Ø£ÙÙ†ÙÙ‘Ù‡Ù|\s+Ø£ÙÙ†ÙÙ‘)",
            r"^Ø¹Ù† (.+?)(?:\s+Ø±Ø¶ÙŠ|\s+Ù‚Ø§Ù„|\s+Ø£Ù†Ù‡|\s+Ø£Ù†)",
        ]
        for pat in patterns:
            m = re.match(pat, arabic_text)
            if m:
                return m.group(1).strip()
        return ""

    # â”€â”€ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_by_id(self, hadith_id: int) -> Optional[Dict[str, Any]]:
        return self._index.get(hadith_id)

    def get_random(self) -> Optional[Dict[str, Any]]:
        return random.choice(self.hadiths) if self.hadiths else None

    def get_all(self) -> List[Dict[str, Any]]:
        return self.hadiths

    def search(self, keyword: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Ø¨Ø­Ø« Ø°ÙƒÙŠ Ù…ØªÙ‚Ø¯Ù…:
        - ÙŠØ¯Ø¹Ù… ÙƒÙ„Ù…Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© (ÙƒÙ„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙŠØ¬Ø¨ Ø£Ù† ØªØªÙˆØ§Ø¬Ø¯)
        - ÙŠØ¨Ø­Ø« ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ (Ø¹Ù†ÙˆØ§Ù†ØŒ Ù†ØµØŒ Ø±Ø§ÙˆÙŠØŒ Ù…ÙØ±Ø¯Ø§ØªØŒ ÙÙˆØ§Ø¦Ø¯ØŒ Ù…ØµØ¯Ø±ØŒ Ù…ÙˆØ¶ÙˆØ¹Ø§Øª)
        - ÙŠØ±ØªØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ø§Ù„ØµÙ„Ø© (ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… Ø§Ù„ØªØ·Ø§Ø¨Ù‚ Ø§Ù„ÙƒØ§Ù…Ù„ØŒ Ø«Ù… Ø§Ù„Ø¬Ø²Ø¦ÙŠ)
        """
        kw = keyword.strip().lower()
        if not kw:
            return []

        # Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø­Ø« Ø¨ÙƒÙ„Ù…Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
        words = kw.split()

        scored = []
        for hadith in self.hadiths:
            title      = hadith.get("title", "").lower()
            text       = hadith.get("text", "").lower()
            narrator   = hadith.get("narrator", "").lower()
            source     = hadith.get("source", "").lower()
            topics     = " ".join(hadith.get("topics_arabic", [])).lower()
            vocabulary = " ".join(
                v if isinstance(v, str) else v.get("word", "") + " " + v.get("meaning", "")
                for v in hadith.get("vocabulary", [])
            ).lower()
            benefits   = " ".join(
                b if isinstance(b, str) else ""
                for b in hadith.get("benefits", [])
            ).lower()

            full_text = f"{title} {text} {narrator} {source} {topics} {vocabulary} {benefits}"

            # ØªØ­Ù‚Ù‚ Ø£Ù† ÙƒÙ„ ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø¨Ø­Ø« Ù…ÙˆØ¬ÙˆØ¯Ø©
            if not all(w in full_text for w in words):
                continue

            # Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØµÙ„Ø©
            score = 0
            if kw in title:           score += 100   # ØªØ·Ø§Ø¨Ù‚ ÙƒØ§Ù…Ù„ ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
            if all(w in title for w in words): score += 50   # ÙƒÙ„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
            if kw in text:            score += 30    # ØªØ·Ø§Ø¨Ù‚ ÙƒØ§Ù…Ù„ ÙÙŠ Ø§Ù„Ù†Øµ
            if kw in topics:          score += 20    # ÙÙŠ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª
            if kw in narrator:        score += 15    # ÙÙŠ Ø§Ù„Ø±Ø§ÙˆÙŠ
            if kw in vocabulary:      score += 10    # ÙÙŠ Ø§Ù„Ù…ÙØ±Ø¯Ø§Øª
            if kw in benefits:        score += 10    # ÙÙŠ Ø§Ù„ÙÙˆØ§Ø¦Ø¯
            # Ù…ÙƒØ§ÙØ£Ø© Ø¹Ù„Ù‰ Ù‚ÙØµÙØ± Ø§Ù„Ù†Øµ (Ø§Ù„Ø­Ø¯ÙŠØ« Ø£ÙƒØ«Ø± ØªØ±ÙƒÙŠØ²Ø§Ù‹)
            score += max(0, 10 - len(text) // 100)

            scored.append((score, hadith))

        scored.sort(key=lambda x: x[0], reverse=True)
        return [h for _, h in scored[:limit]]

    def get_related(self, hadith_id: int, limit: int = 3) -> List[Dict[str, Any]]:
        """ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù…Ù† JSON Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… ÙŠØ¹ÙˆØ¯ Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©"""
        current = self.get_by_id(hadith_id)
        if not current:
            return []

        # â”€â”€ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© Ø§Ù„Ù…Ø­Ø±Ø±Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹ â”€â”€
        real_related = current.get("related_hadiths", [])
        if real_related:
            result = []
            for rid in real_related[:limit]:
                h = self.get_by_id(rid)
                if h:
                    result.append(h)
            if result:
                return result

        # â”€â”€ Ø§Ø­ØªÙŠØ§Ø·ÙŠ: Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† â”€â”€
        title_words = set(current.get("title", "").split())
        scored: List[Tuple[int, Dict[str, Any]]] = []
        for hadith in self.hadiths:
            if hadith["id"] == hadith_id:
                continue
            common = title_words & set(hadith.get("title", "").split())
            if common:
                scored.append((len(common), hadith))
        scored.sort(key=lambda x: x[0], reverse=True)
        return [h for _, h in scored[:limit]]

    def get_categories(self) -> Dict[str, List[int]]:
        """Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª Ù…Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ù„ÙƒÙ„ ØªØµÙ†ÙŠÙ"""
        return self._topics_index

    def get_by_category(self, category: str) -> List[Dict[str, Any]]:
        ids = self._topics_index.get(category, [])
        return [self._index[i] for i in ids if i in self._index]

    def get_qudsi_hadiths(self) -> List[Dict[str, Any]]:
        return [h for h in self.hadiths if h.get("hadith_type") == "qudsi"]

    def __len__(self) -> int:
        return len(self.hadiths)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 4. Ø¥Ø¯Ø§Ø±Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ù…Ø­Ø³Ù‘Ù†Ø© Ø¨Ù…ÙŠØ²Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€ ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø´Ø§Ø±Ø§Øª â”€â”€
BADGES: Dict[str, Dict[str, Any]] = {
    "seedling":   {"emoji": "ğŸŒ±", "name": "Ù…Ø¨ØªØ¯Ø¦",          "desc": "Ù‚Ø±Ø§Ø¡Ø© 5 Ø£Ø­Ø§Ø¯ÙŠØ«",       "check": lambda d: len(d.get("read_hadiths", [])) >= 5},
    "student":    {"emoji": "ğŸ“š", "name": "Ø·Ø§Ù„Ø¨ Ø¹Ù„Ù…",        "desc": "Ù‚Ø±Ø§Ø¡Ø© 20 Ø­Ø¯ÙŠØ«Ø§Ù‹",      "check": lambda d: len(d.get("read_hadiths", [])) >= 20},
    "graduate":   {"emoji": "ğŸ“", "name": "Ø§Ù„Ø®Ø±ÙŠØ¬",          "desc": "Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ù€ 42",         "check": lambda d: len(d.get("read_hadiths", [])) >= 42},
    "champion":   {"emoji": "ğŸ†", "name": "Ø§Ù„Ø­Ø§ÙØ¸",          "desc": "Ù†ØªÙŠØ¬Ø© 100% ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø±", "check": lambda d: any(q.get("percentage", 0) == 100 for q in d.get("quiz_scores", []))},
    "starred":    {"emoji": "â­", "name": "Ø§Ù„Ù…Ù…ÙŠØ²",           "desc": "10 Ø£Ø­Ø§Ø¯ÙŠØ« ÙÙŠ Ø§Ù„Ù…ÙØ¶Ù„Ø©", "check": lambda d: len(d.get("favorites", [])) >= 10},
    "writer":     {"emoji": "ğŸ“", "name": "Ø§Ù„ÙƒØ§ØªØ¨",           "desc": "10 Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…ÙƒØªÙˆØ¨Ø©",   "check": lambda d: len(d.get("notes", {})) >= 10},
    "streak7":    {"emoji": "ğŸ”¥", "name": "Ø§Ù„Ø«Ø§Ø¨Øª",           "desc": "7 Ø£ÙŠØ§Ù… Ù…ØªÙˆØ§ØµÙ„Ø©",       "check": lambda d: d.get("streak_count", 0) >= 7},
    "streak30":   {"emoji": "ğŸ’", "name": "Ø§Ù„Ù…Ø¯Ø§ÙˆÙ…",          "desc": "30 ÙŠÙˆÙ… Ù…ØªÙˆØ§ØµÙ„Ø©",       "check": lambda d: d.get("streak_count", 0) >= 30},
    "flashcard":  {"emoji": "ğŸƒ", "name": "Ø§Ù„Ù…ØªØ¯Ø±Ø¨",          "desc": "10 Ø¨Ø·Ø§Ù‚Ø§Øª Ø­ÙØ¸ Ù…Ø±Ø§Ø¬Ø¹Ø©", "check": lambda d: d.get("flashcard_count", 0) >= 10},
}

_USER_DEFAULTS: Dict[str, Any] = {
    "read_hadiths":          [],
    "favorites":             [],
    "notes":                 {},
    "quiz_scores":           [],
    "study_plan":            [],
    "last_daily":            None,
    "interaction_count":     0,
    "last_support_reminder": None,
    "reminder_enabled":      False,
    "reminder_time":         DEFAULT_REMINDER_TIME,
    "reminder_time_evening": None,     # â† ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ (Ø¬Ø¯ÙŠØ¯)
    "reminder_timezone":     DEFAULT_TIMEZONE,
    "last_reminder_sent":    None,
    "last_reminder_evening": None,     # â† (Ø¬Ø¯ÙŠØ¯)
    "streak_count":          0,        # â† Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© (Ø¬Ø¯ÙŠØ¯)
    "streak_last_date":      None,     # â† (Ø¬Ø¯ÙŠØ¯)
    "streak_best":           0,        # â† Ø£Ø¹Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© (Ø¬Ø¯ÙŠØ¯)
    "flashcard_count":       0,        # â† Ø¹Ø¯Ø¯ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„ØªÙŠ Ø±Ø§Ø¬Ø¹Ù‡Ø§ (Ø¬Ø¯ÙŠØ¯)
    "earned_badges":         [],       # â† Ø§Ù„Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø© (Ø¬Ø¯ÙŠØ¯)
    "weekly_reads":          {},       # â† Ù‚Ø±Ø§Ø¡Ø§Øª Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© {ISO_week: count} (Ø¬Ø¯ÙŠØ¯)
    "self_assessment":       {},       # â† Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù {hadith_id: bool} (Ø¬Ø¯ÙŠØ¯)
}


class UserDataManager:
    """Ø¥Ø¯Ø§Ø±Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©"""

    def __init__(self, data_dir: Path) -> None:
        self.data_dir = data_dir

    def _get_path(self, user_id: int) -> Path:
        return self.data_dir / f"user_{user_id}.json"

    def _load(self, user_id: int) -> Dict[str, Any]:
        path = self._get_path(user_id)
        if not path.exists():
            return dict(_USER_DEFAULTS)
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            for key, default in _USER_DEFAULTS.items():
                if key not in data:
                    data[key] = default
            return data
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª {user_id}: {exc}")
            return dict(_USER_DEFAULTS)

    def _save(self, user_id: int, data: Dict[str, Any]) -> bool:
        try:
            with open(self._get_path(user_id), "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            return True
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª {user_id}: {exc}")
            return False

    def _update_field(self, user_id: int, **fields) -> bool:
        data = self._load(user_id)
        data.update(fields)
        return self._save(user_id, data)

    # â”€â”€ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def mark_as_read(self, user_id: int, hadith_id: int) -> bool:
        data = self._load(user_id)
        if hadith_id not in data["read_hadiths"]:
            data["read_hadiths"].append(hadith_id)
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
            week_key = datetime.now().strftime("%Y-W%W")
            data["weekly_reads"][week_key] = data["weekly_reads"].get(week_key, 0) + 1
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
            self._update_streak_in_data(data)
            return self._save(user_id, data)
        return True

    def _update_streak_in_data(self, data: Dict[str, Any]) -> None:
        """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø¯Ø§Ø®Ù„ ÙƒØ§Ø¦Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø©"""
        today = datetime.now().date().isoformat()
        last  = data.get("streak_last_date")
        if last == today:
            return  # Ù†ÙØ³ Ø§Ù„ÙŠÙˆÙ…
        yesterday = (datetime.now().date() - timedelta(days=1)).isoformat()
        if last == yesterday:
            data["streak_count"] = data.get("streak_count", 0) + 1
        else:
            data["streak_count"] = 1  # Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ù„Ø³Ù„Ø©
        data["streak_last_date"] = today
        if data["streak_count"] > data.get("streak_best", 0):
            data["streak_best"] = data["streak_count"]

    def get_read_hadiths(self, user_id: int) -> List[int]:
        return self._load(user_id).get("read_hadiths", [])

    def get_unread_hadiths(self, user_id: int, total: int) -> List[int]:
        read = set(self.get_read_hadiths(user_id))
        return [i for i in range(1, total + 1) if i not in read]

    # â”€â”€ Ø§Ù„Ù…ÙØ¶Ù„Ø© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def add_favorite(self, user_id: int, hadith_id: int) -> bool:
        data = self._load(user_id)
        if hadith_id not in data["favorites"]:
            data["favorites"].append(hadith_id)
            return self._save(user_id, data)
        return True

    def remove_favorite(self, user_id: int, hadith_id: int) -> bool:
        data = self._load(user_id)
        if hadith_id in data["favorites"]:
            data["favorites"].remove(hadith_id)
            return self._save(user_id, data)
        return True

    def get_favorites(self, user_id: int) -> List[int]:
        return self._load(user_id).get("favorites", [])

    def is_favorite(self, user_id: int, hadith_id: int) -> bool:
        return hadith_id in self.get_favorites(user_id)

    # â”€â”€ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def add_note(self, user_id: int, hadith_id: int, note: str) -> bool:
        data = self._load(user_id)
        data["notes"][str(hadith_id)] = {
            "text": note,
            "timestamp": datetime.now().isoformat(),
        }
        return self._save(user_id, data)

    def get_note(self, user_id: int, hadith_id: int) -> Optional[str]:
        entry = self._load(user_id).get("notes", {}).get(str(hadith_id))
        return entry.get("text") if entry else None

    def delete_note(self, user_id: int, hadith_id: int) -> bool:
        data = self._load(user_id)
        key = str(hadith_id)
        if key in data.get("notes", {}):
            del data["notes"][key]
            return self._save(user_id, data)
        return True

    # â”€â”€ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def save_quiz_score(self, user_id: int, score: int, total: int) -> bool:
        data = self._load(user_id)
        data["quiz_scores"].append({
            "score":      score,
            "total":      total,
            "percentage": round((score / total) * 100, 2) if total else 0,
            "timestamp":  datetime.now().isoformat(),
        })
        return self._save(user_id, data)

    def get_quiz_history(self, user_id: int) -> List[Dict[str, Any]]:
        return self._load(user_id).get("quiz_scores", [])

    # â”€â”€ Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_last_daily(self, user_id: int) -> Optional[str]:
        return self._load(user_id).get("last_daily")

    def update_last_daily(self, user_id: int) -> bool:
        return self._update_field(user_id, last_daily=datetime.now().date().isoformat())

    # â”€â”€ Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def set_study_plan(self, user_id: int, plan: List[int]) -> bool:
        return self._update_field(user_id, study_plan=plan)

    def get_study_plan(self, user_id: int) -> List[int]:
        return self._load(user_id).get("study_plan", [])

    # â”€â”€ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª ÙˆØ§Ù„Ø¯Ø¹Ù… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def increment_interaction(self, user_id: int) -> int:
        data = self._load(user_id)
        data["interaction_count"] = data.get("interaction_count", 0) + 1
        self._save(user_id, data)
        return data["interaction_count"]

    def update_support_reminder(self, user_id: int) -> bool:
        return self._update_field(user_id, last_support_reminder=datetime.now().isoformat())

    def should_show_support_reminder(self, user_id: int) -> bool:
        if SUPPORT_REMINDER_INTERVAL <= 0:
            return False
        count = self._load(user_id).get("interaction_count", 0)
        return count > 0 and count % SUPPORT_REMINDER_INTERVAL == 0

    # â”€â”€ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def enable_reminder(self, user_id: int, time_str: str, timezone: str = DEFAULT_TIMEZONE) -> bool:
        return self._update_field(user_id, reminder_enabled=True, reminder_time=time_str, reminder_timezone=timezone)

    def enable_evening_reminder(self, user_id: int, time_str: str) -> bool:
        return self._update_field(user_id, reminder_time_evening=time_str)

    def disable_evening_reminder(self, user_id: int) -> bool:
        return self._update_field(user_id, reminder_time_evening=None)

    def disable_reminder(self, user_id: int) -> bool:
        return self._update_field(user_id, reminder_enabled=False)

    def get_reminder_settings(self, user_id: int) -> Dict[str, Any]:
        data = self._load(user_id)
        return {
            "enabled":         data.get("reminder_enabled", False),
            "time":            data.get("reminder_time", DEFAULT_REMINDER_TIME),
            "time_evening":    data.get("reminder_time_evening"),
            "timezone":        data.get("reminder_timezone", DEFAULT_TIMEZONE),
            "last_sent":       data.get("last_reminder_sent"),
            "last_evening":    data.get("last_reminder_evening"),
        }

    def update_last_reminder_sent(self, user_id: int, evening: bool = False) -> bool:
        if evening:
            return self._update_field(user_id, last_reminder_evening=datetime.now().isoformat())
        return self._update_field(user_id, last_reminder_sent=datetime.now().isoformat())

    def get_all_users(self) -> List[Tuple[int, Dict[str, Any]]]:
        """Ø¥Ø±Ø¬Ø§Ø¹ ÙƒÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§ØªÙ‡Ù… Ø§Ù„ÙƒØ§Ù…Ù„Ø©"""
        users = []
        for path in self.data_dir.glob("user_*.json"):
            try:
                uid  = int(path.stem.split("_")[1])
                data = self._load(uid)
                users.append((uid, data))
            except Exception as exc:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© {path}: {exc}")
        return users

    def is_banned(self, user_id: int) -> bool:
        return self._load(user_id).get("banned", False)

    def ban_user(self, user_id: int) -> bool:
        return self._update_field(user_id, banned=True)

    def unban_user(self, user_id: int) -> bool:
        return self._update_field(user_id, banned=False)

    def get_all_users_with_reminders(self) -> List[Tuple[int, Dict[str, Any]]]:
        users: List[Tuple[int, Dict[str, Any]]] = []
        for path in self.data_dir.glob("user_*.json"):
            try:
                uid  = int(path.stem.split("_")[1])
                data = self._load(uid)
                if data.get("reminder_enabled"):
                    users.append((uid, {
                        "time":         data.get("reminder_time", DEFAULT_REMINDER_TIME),
                        "time_evening": data.get("reminder_time_evening"),
                        "timezone":     data.get("reminder_timezone", DEFAULT_TIMEZONE),
                        "last_sent":    data.get("last_reminder_sent"),
                        "last_evening": data.get("last_reminder_evening"),
                    }))
            except Exception as exc:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© {path}: {exc}")
        return users

    # â”€â”€ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_streak(self, user_id: int) -> Dict[str, Any]:
        data = self._load(user_id)
        return {
            "count": data.get("streak_count", 0),
            "best":  data.get("streak_best", 0),
            "last":  data.get("streak_last_date"),
        }

    # â”€â”€ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def increment_flashcard(self, user_id: int) -> int:
        data = self._load(user_id)
        data["flashcard_count"] = data.get("flashcard_count", 0) + 1
        self._save(user_id, data)
        return data["flashcard_count"]

    # â”€â”€ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°Ø§ØªÙŠ (Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def save_self_assessment(self, user_id: int, hadith_id: int, knows: bool) -> bool:
        data = self._load(user_id)
        data["self_assessment"][str(hadith_id)] = knows
        return self._save(user_id, data)

    def get_needs_review(self, user_id: int) -> List[int]:
        data = self._load(user_id)
        return [int(k) for k, v in data.get("self_assessment", {}).items() if not v]

    # â”€â”€ Ø§Ù„Ø´Ø§Ø±Ø§Øª â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def check_and_award_badges(self, user_id: int) -> List[str]:
        """ÙŠØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³ØªØ­Ù‚Ø© ÙˆÙŠÙ…Ù†Ø­ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© â€” ÙŠÙØ¹ÙŠØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©"""
        data      = self._load(user_id)
        earned    = set(data.get("earned_badges", []))
        new_ones  = []
        for badge_id, badge in BADGES.items():
            if badge_id not in earned and badge["check"](data):
                earned.add(badge_id)
                new_ones.append(badge_id)
        if new_ones:
            data["earned_badges"] = list(earned)
            self._save(user_id, data)
        return new_ones

    def get_earned_badges(self, user_id: int) -> List[str]:
        return self._load(user_id).get("earned_badges", [])

    # â”€â”€ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_statistics(self, user_id: int, total_hadiths: int) -> Dict[str, Any]:
        data       = self._load(user_id)
        read_count = len(data.get("read_hadiths", []))
        quiz_scores = data.get("quiz_scores", [])
        avg_score  = (
            sum(q["percentage"] for q in quiz_scores) / len(quiz_scores)
            if quiz_scores else 0
        )
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
        week_key   = datetime.now().strftime("%Y-W%W")
        week_reads = data.get("weekly_reads", {}).get(week_key, 0)
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¢Ø®Ø± 7 Ø£ÙŠØ§Ù…
        last_7_keys = [
            (datetime.now().date() - timedelta(days=i)).strftime("%Y-W%W")
            for i in range(7)
        ]
        week_reads_7 = sum(data.get("weekly_reads", {}).get(k, 0) for k in set(last_7_keys))
        # Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø© ÙÙŠ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
        best_quiz = max((q["percentage"] for q in quiz_scores), default=0)
        return {
            "read_hadiths":        read_count,
            "total_hadiths":       total_hadiths,
            "progress_percentage": round((read_count / total_hadiths) * 100, 2) if total_hadiths else 0,
            "favorites":           len(data.get("favorites", [])),
            "notes":               len(data.get("notes", {})),
            "quizzes_taken":       len(quiz_scores),
            "average_quiz_score":  round(avg_score, 2),
            "best_quiz_score":     round(best_quiz, 2),
            "streak":              data.get("streak_count", 0),
            "streak_best":         data.get("streak_best", 0),
            "week_reads":          week_reads_7,
            "earned_badges":       data.get("earned_badges", []),
            "flashcard_count":     data.get("flashcard_count", 0),
            "needs_review":        len([v for v in data.get("self_assessment", {}).values() if not v]),
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 5. Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ø­Ø§Ù„Ø©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ConversationMemory:
    """Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª â€” ØªØ­ØªÙØ¸ Ø¨Ø³ÙŠØ§Ù‚ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø£Ø®ÙŠØ± Ù„ØªØ­Ø³ÙŠÙ† AI"""

    def __init__(self, max_history: int = MAX_CONVERSATION_HISTORY) -> None:
        self._sessions: Dict[int, deque] = {}
        self._active_hadith: Dict[int, int] = {}   # user_id â†’ hadith_id Ø§Ù„Ù…Ù†Ø§Ù‚ÙØ´
        self.max_history = max_history

    def get(self, user_id: int) -> deque:
        if user_id not in self._sessions:
            self._sessions[user_id] = deque(maxlen=self.max_history)
        return self._sessions[user_id]

    def add_message(self, user_id: int, role: str, content: str) -> None:
        self.get(user_id).append({"role": role, "content": content})

    def set_active_hadith(self, user_id: int, hadith_id: int) -> None:
        self._active_hadith[user_id] = hadith_id

    def get_active_hadith(self, user_id: int) -> Optional[int]:
        return self._active_hadith.get(user_id)

    def clear(self, user_id: int) -> None:
        if user_id in self._sessions:
            self._sessions[user_id].clear()
        self._active_hadith.pop(user_id, None)


class FeedbackSystem:
    _waiting: Dict[int, bool] = {}

    @classmethod
    def start(cls, user_id: int) -> None:
        cls._waiting[user_id] = True

    @classmethod
    def stop(cls, user_id: int) -> None:
        cls._waiting.pop(user_id, None)

    @classmethod
    def is_active(cls, user_id: int) -> bool:
        return cls._waiting.get(user_id, False)


class NoteSystem:
    _waiting: Dict[int, int] = {}

    @classmethod
    def start(cls, user_id: int, hadith_id: int) -> None:
        cls._waiting[user_id] = hadith_id

    @classmethod
    def stop(cls, user_id: int) -> None:
        cls._waiting.pop(user_id, None)

    @classmethod
    def is_active(cls, user_id: int) -> bool:
        return user_id in cls._waiting

    @classmethod
    def get_hadith_id(cls, user_id: int) -> Optional[int]:
        return cls._waiting.get(user_id)


class FlashcardSystem:
    """Ø­Ø§Ù„Ø© Ø¬Ù„Ø³Ø© Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸"""
    _sessions: Dict[int, Dict[str, Any]] = {}

    @classmethod
    def start(cls, user_id: int, hadith_ids: List[int]) -> None:
        random.shuffle(hadith_ids)
        cls._sessions[user_id] = {
            "queue":   hadith_ids,
            "index":   0,
            "correct": 0,
            "total":   len(hadith_ids),
        }

    @classmethod
    def get_current(cls, user_id: int) -> Optional[int]:
        s = cls._sessions.get(user_id)
        if not s or s["index"] >= len(s["queue"]):
            return None
        return s["queue"][s["index"]]

    @classmethod
    def advance(cls, user_id: int, knew_it: bool) -> bool:
        """ÙŠÙÙ‚Ø¯Ù‘Ù… Ù„Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© â€” ÙŠÙØ¹ÙŠØ¯ True Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬Ù„Ø³Ø©"""
        s = cls._sessions.get(user_id)
        if not s:
            return True
        if knew_it:
            s["correct"] += 1
        s["index"] += 1
        return s["index"] >= len(s["queue"])

    @classmethod
    def get_result(cls, user_id: int) -> Optional[Dict[str, Any]]:
        return cls._sessions.pop(user_id, None)

    @classmethod
    def is_active(cls, user_id: int) -> bool:
        return user_id in cls._sessions

    @classmethod
    def cancel(cls, user_id: int) -> None:
        cls._sessions.pop(user_id, None)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 6. Ø£Ù†Ø¸Ù…Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SupportSystem:
    _MESSAGES = [
        "ğŸ’ *Ù‡Ù„ Ø§Ø³ØªÙØ¯Øª Ù…Ù† Ù†Ø¨Ø±Ø§Ø³ØŸ*\n\nØ¯Ø¹Ù…Ùƒ ÙŠØ³Ø§Ø¹Ø¯Ù†Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±! â˜•\nÙƒÙˆØ¨ Ù‚Ù‡ÙˆØ© ØµØºÙŠØ± = ØªØ­ÙÙŠØ² ÙƒØ¨ÙŠØ± ğŸŒŸ",
        "ğŸŒŸ *Ù†Ø¨Ø±Ø§Ø³ ÙŠØ³Ø¹Ø¯ Ø¨Ø®Ø¯Ù…ØªÙƒ!*\n\nØ¥Ù† Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡ ÙŠÙ†ÙØ¹ Ø§Ù„Ù„Ù‡ Ø¨Ùƒ âœ¨\nØ¯Ø¹Ù…Ùƒ ÙŠØ¹ÙŠÙ†Ù†Ø§ Ø¹Ù„Ù‰ Ø§Ù„ØªØ·ÙˆÙŠØ± â˜•",
        "âœ¨ *Ø¬Ø²Ø§Ùƒ Ø§Ù„Ù„Ù‡ Ø®ÙŠØ±Ø§Ù‹ Ø¹Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ùƒ Ù†Ø¨Ø±Ø§Ø³*\n\nÙ…Ø³Ø§Ù‡Ù…ØªÙƒ ØªØ³Ø§Ø¹Ø¯ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¨ÙˆØª ğŸ’ª",
        "ğŸ¯ *Ù†Ø¨Ø±Ø§Ø³ ÙÙŠ Ø®Ø¯Ù…ØªÙƒ Ø¯Ø§Ø¦Ù…Ø§Ù‹*\n\nØ³Ø§Ø¹Ø¯Ù†Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ø¹Ø·Ø§Ø¡ ğŸŒ±",
    ]

    @staticmethod
    def get_button() -> InlineKeyboardButton:
        return InlineKeyboardButton("â˜• Ø§Ø¯Ø¹Ù… Ø§Ù„Ø¨ÙˆØª", url=SUPPORT_LINK)

    @staticmethod
    def get_message() -> str:
        return random.choice(SupportSystem._MESSAGES)

    @staticmethod
    def get_stats_footer() -> str:
        return (
            "\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "ğŸ’ *Ø§Ø³ØªÙ…ØªØ¹Øª Ø¨Ù†Ø¨Ø±Ø§Ø³ØŸ*\n"
            "Ø³Ø§Ø¹Ø¯Ù†Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± â˜•\n"
            f"[Ø§Ø¯Ø¹Ù… Ø§Ù„Ø¨ÙˆØª Ù‡Ù†Ø§]({SUPPORT_LINK})"
        )


class MonetagSystem:
    """
    Ù†Ø¸Ø§Ù… Ø¥Ø¹Ù„Ø§Ù†Ø§Øª Monetag (Interstitial/Pop) Ù„Ù„Ø¨ÙˆØª
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Ø¢Ù„ÙŠØ© Ø§Ù„Ø¹Ù…Ù„:
      - ÙŠÙØ±Ø³Ù„ Ø±Ø§Ø¨Ø· Monetag Direct Link ÙƒØ²Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      - Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· ÙŠÙÙØªØ­ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ (Interstitial/Pop)

    Ø§Ù„Ø£Ù…Ø§ÙƒÙ† Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©:
      1. Ø¨Ø¹Ø¯ Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± (Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±)
      2. Ø¨Ø¹Ø¯ Ø¥ØªÙ…Ø§Ù… Ø¬Ù„Ø³Ø© Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸
      3. ÙƒÙ„ MONETAG_INTERVAL ØªÙØ§Ø¹Ù„ (Ø´Ø±Ø­ AI)
      4. Ø¨Ø¹Ø¯ Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©/ÙŠÙˆÙ…)

    Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:
      MONETAG_ENABLED      = True/False
      MONETAG_DIRECT_LINK  = https://omg10.com/4/10632325  (Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø¨Ø§Ø´Ø±)
    """

    @staticmethod
    def _get_ad_url() -> str:
        """Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø¥Ø¹Ù„Ø§Ù†"""
        return os.getenv("MONETAG_DIRECT_LINK", MONETAG_DIRECT_LINK).strip()

    @classmethod
    async def send_ad(
        cls,
        bot,
        chat_id: int,
        context_label: str = "",
    ) -> bool:
        """
        Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø¹Ù„Ø§Ù† Monetag â€” ÙŠÙØ¹ÙŠØ¯ True Ø¥Ø°Ø§ Ù†Ø¬Ø­ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        context_label: Ù†Øµ ØªØ´Ø¬ÙŠØ¹ÙŠ ÙŠØ¸Ù‡Ø± ÙÙˆÙ‚ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†
        """
        if not MONETAG_ENABLED:
            return False

        ad_url = cls._get_ad_url()
        if not ad_url:
            logger.warning("Monetag: MONETAG_DIRECT_LINK ØºÙŠØ± Ù…Ø¶Ø¨ÙˆØ·ØŒ ØªÙ… ØªØ®Ø·ÙŠ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†.")
            return False

        try:
            header = "ğŸ“¢ *Ø¥Ø¹Ù„Ø§Ù†*"
            if context_label:
                header = f"{context_label}\n\nğŸ“¢ *Ø¥Ø¹Ù„Ø§Ù†*"

            message_text = (
                f"{header}\n\n"
                "ğŸŒ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¯Ø¹Ù… Ø§Ù„Ø¨ÙˆØª ÙˆÙ…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†:"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”— Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†", url=ad_url)]
            ])

            await bot.send_message(
                chat_id=chat_id,
                text=message_text,
                reply_markup=keyboard,
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=True,
            )

            logger.info(f"ğŸ“¢ Monetag ad sent â†’ {chat_id} [{context_label}]")
            return True

        except Exception as exc:
            logger.debug(f"Monetag send error: {exc}")
            return False

    @classmethod
    def should_show_interval_ad(cls, user_id: int, current_interactions: int) -> bool:
        """Ù‡Ù„ Ø­Ø§Ù† ÙˆÙ‚Øª Ø¥Ø¹Ù„Ø§Ù† Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„Ø¯ÙˆØ±ÙŠØŸ"""
        if MONETAG_INTERVAL <= 0:
            return False
        last = _monetag_last_shown.get(user_id, 0)
        if current_interactions - last >= MONETAG_INTERVAL:
            _monetag_last_shown[user_id] = current_interactions
            return True
        return False


class ReminderSystem:
    @staticmethod
    def parse_time(time_str: str) -> Optional[datetime_time]:
        try:
            h, m = map(int, time_str.split(":"))
            if 0 <= h < 24 and 0 <= m < 60:
                return datetime_time(hour=h, minute=m)
        except (ValueError, AttributeError):
            pass
        return None

    @staticmethod
    def should_send(last_sent: Optional[str], timezone_str: str) -> bool:
        if not last_sent:
            return True
        try:
            tz   = ZoneInfo(timezone_str)
            last = datetime.fromisoformat(last_sent)
            # âœ… Ø¥ØµÙ„Ø§Ø­: ØªØ£ÙƒØ¯ Ø£Ù† last ÙŠØ­Ù…Ù„ timezone Ù‚Ø¨Ù„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
            if last.tzinfo is None:
                last = last.replace(tzinfo=tz)
            return last.astimezone(tz).date() < datetime.now(tz).date()
        except Exception:
            return True

    @staticmethod
    def build_message(hadith: Dict[str, Any], unread_count: int = 0) -> str:
        streak_line = ""
        base = (
            "â° *ØªØ°ÙƒÙŠØ±Ùƒ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ù…Ù† Ù†Ø¨Ø±Ø§Ø³*\n\n"
            f"ğŸ“– *Ø§Ù„Ø­Ø¯ÙŠØ« Ø±Ù‚Ù… {hadith['id']}: {MessageFormatter.esc(hadith['title'])}*\n\n"
            f"Â«{MessageFormatter.esc(hadith['text'][:300])}Â»\n\n"
            f"ğŸ“š *Ø§Ù„Ø±Ø§ÙˆÙŠ:* {MessageFormatter.esc(hadith['narrator'])}\n"
        )
        if unread_count > 0:
            base += f"ğŸ“š *ØªØ¨Ù‚Ù‰ Ù„Ùƒ:* {unread_count} Ø­Ø¯ÙŠØ«Ø§Ù‹ Ù„Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ†!\n"
        base += "\nğŸ’¡ Ø§Ø³ØªØ®Ø¯Ù… /reminder Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ"
        return base

    @staticmethod
    def build_evening_message(hadith: Dict[str, Any]) -> str:
        return (
            "ğŸŒ™ *Ø­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø§Ø¡ Ù…Ù† Ù†Ø¨Ø±Ø§Ø³*\n\n"
            f"ğŸ“– *{MessageFormatter.esc(hadith['title'])}*\n\n"
            f"Â«{MessageFormatter.esc(hadith['text'][:300])}Â»\n\n"
            "ğŸ’­ ØªØ£Ù…Ù„ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ« Ù‚Ø¨Ù„ Ù†ÙˆÙ…Ùƒ ğŸŒŸ"
        )


class SmartQuestionSystem:
    _KEYWORD_QUESTIONS: Dict[str, str] = {
        "Ù†ÙŠØ©":   "Ù…Ø§ Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ù†ÙŠØ© ÙÙŠ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ØŸ",
        "Ø¥ÙŠÙ…Ø§Ù†": "ÙƒÙŠÙ Ù†Ù‚ÙˆÙŠ Ø§Ù„Ø¥ÙŠÙ…Ø§Ù† Ù…Ù† Ø®Ù„Ø§Ù„ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ«ØŸ",
        "ØµÙ„Ø§Ø©":  "Ù…Ø§ Ø§Ù„Ø£Ø­ÙƒØ§Ù… Ø§Ù„Ù…Ø³ØªÙØ§Ø¯Ø© Ø¹Ù† Ø§Ù„ØµÙ„Ø§Ø©ØŸ",
        "ØµÙˆÙ…":   "Ù…Ø§ ÙØ¶Ù„ Ø§Ù„ØµÙŠØ§Ù… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ«ØŸ",
        "Ø²ÙƒØ§Ø©":  "Ù…Ø§ Ø´Ø±ÙˆØ· Ø§Ù„Ø²ÙƒØ§Ø© Ø§Ù„Ù…Ø°ÙƒÙˆØ±Ø©ØŸ",
        "Ø­Ø¬":    "Ù…Ø§ Ø£Ø±ÙƒØ§Ù† Ø§Ù„Ø­Ø¬ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©ØŸ",
        "ØªÙ‚ÙˆÙ‰":  "ÙƒÙŠÙ Ù†Ø­Ù‚Ù‚ Ø§Ù„ØªÙ‚ÙˆÙ‰ Ø¹Ù…Ù„ÙŠØ§Ù‹ØŸ",
        "ØµØ¯Ù‚":   "Ù…Ø§ Ø«Ù…Ø±Ø§Øª Ø§Ù„ØµØ¯Ù‚ØŸ",
        "Ø­Ù„Ø§Ù„":  "ÙƒÙŠÙ Ù†Ù…ÙŠØ² Ø¨ÙŠÙ† Ø§Ù„Ø­Ù„Ø§Ù„ ÙˆØ§Ù„Ø­Ø±Ø§Ù…ØŸ",
        "Ø­Ø±Ø§Ù…":  "Ù„Ù…Ø§Ø°Ø§ Ø­ÙØ±Ù… Ù…Ø§ Ø°ÙÙƒØ± ÙÙŠ Ø§Ù„Ø­Ø¯ÙŠØ«ØŸ",
        "Ø±Ø­Ù…Ø©":  "ÙƒÙŠÙ Ù†Ø¬Ø³Ù‘Ø¯ Ø§Ù„Ø±Ø­Ù…Ø© ÙÙŠ Ø­ÙŠØ§ØªÙ†Ø§ØŸ",
        "Ø¸Ù„Ù…":   "Ù…Ø§ Ø¹Ù‚ÙˆØ¨Ø© Ø§Ù„Ø¸Ù„Ù… Ø§Ù„Ù…Ø³ØªÙØ§Ø¯Ø©ØŸ",
    }

    @classmethod
    def generate(cls, hadith: Dict[str, Any]) -> List[str]:
        questions = [
            f"Ù…Ø§ Ø§Ù„Ù…Ø¹Ù†Ù‰ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ù„Ù„Ø­Ø¯ÙŠØ« Ø±Ù‚Ù… {hadith['id']}ØŸ",
            f"Ù…Ø§ Ø§Ù„ÙÙˆØ§Ø¦Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…Ù† Ø­Ø¯ÙŠØ« {hadith['title']}ØŸ",
            f"ÙƒÙŠÙ Ø£Ø·Ø¨Ù‚ Ø­Ø¯ÙŠØ« '{hadith['title']}' ÙÙŠ Ø­ÙŠØ§ØªÙŠ Ø§Ù„ÙŠÙˆÙ…ÙŠØ©ØŸ",
        ]
        if hadith.get("id", 0) > 1:
            questions.append(f"Ù…Ø§ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ø­Ø¯ÙŠØ« {hadith['id']} ÙˆØ§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ø£Ø®Ø±Ù‰ØŸ")
        text = hadith.get("text", "").lower()
        for kw, q in cls._KEYWORD_QUESTIONS.items():
            if kw in text:
                questions.append(q)
        # Ø£Ø³Ø¦Ù„Ø© Ù…Ù† Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª
        for topic in hadith.get("topics_arabic", [])[:2]:
            questions.append(f"ÙƒÙŠÙ ÙŠØªØ¹Ù„Ù‚ Ù…ÙˆØ¶ÙˆØ¹ '{topic}' Ø¨Ø­ÙŠØ§ØªÙ†Ø§ Ø§Ù„ÙŠÙˆÙ…ÙŠØ©ØŸ")
        return random.sample(questions, min(5, len(questions)))

    @classmethod
    def format_message(cls, hadith: Dict[str, Any], count: int = 3) -> str:
        questions = cls.generate(hadith)[:count]
        if not questions:
            return ""
        lines = ["\n\nğŸ’¡ *Ø£Ø³Ø¦Ù„Ø© Ù…Ù‚ØªØ±Ø­Ø© â€” Ø§Ø¶ØºØ· Ù„Ù„Ù†Ø³Ø® Ø«Ù… Ø£Ø±Ø³Ù„Ù‡Ø§:*\n"]
        for i, q in enumerate(questions, 1):
            lines.append(f"{i}. `{q}`\n")
        return "".join(lines).rstrip()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 7. ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ (Ù…Ø­Ø³Ù‘Ù† Ø¨Ø§Ù„ÙƒØ§Ù…Ù„)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MessageFormatter:
    _SUGGESTION_RE = re.compile(r"##(.*?)##", re.DOTALL)

    @staticmethod
    def esc(text: str) -> str:
        """Escape Ø±Ù…ÙˆØ² Markdown Ø§Ù„Ø®Ø·Ø±Ø© ÙÙŠ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©"""
        for ch in ('_', '*', '[', ']', '`'):
            text = text.replace(ch, '\\' + ch)
        return text

    @classmethod
    def format_response(cls, text: str) -> str:
        match = cls._SUGGESTION_RE.search(text)
        clean = cls._SUGGESTION_RE.sub("", text).strip()
        if not match:
            return clean
        suggestion = match.group(1).strip()
        if len(suggestion) < 5 or suggestion == "Ø§Ù„Ø³Ø¤Ø§Ù„":
            return clean
        return (
            clean
            + "\n\nğŸ’¡ *Ø³Ø¤Ø§Ù„ Ù…Ù‚ØªØ±Ø­:*\n"
            "_(Ø§Ù†Ù‚Ø± Ù„Ù„Ù†Ø³Ø®)_\n"
            f"`{suggestion}`"
        )

    @staticmethod
    def build_hadith_display(
        hadith: Dict[str, Any],
        include_actions: bool = False,
        is_favorite: bool = False,
        has_note: bool = False,
    ) -> Tuple[str, Optional[InlineKeyboardMarkup]]:
        """Ø¨Ù†Ø§Ø¡ Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø¯ÙŠØ« â€” ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„ÙØµÙ„ Ø¨ÙŠÙ† Ù…Ù‚Ø¯Ù…Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ ÙˆÙ†Øµ Ø§Ù„Ø­Ø¯ÙŠØ«"""
        hid = hadith["id"]

        # â”€â”€ Ø´Ø§Ø±Ø© Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø¯Ø³ÙŠ â”€â”€
        type_badge = ""
        if hadith.get("hadith_type") == "qudsi":
            type_badge = " âœ¨ *Ù‚Ø¯Ø³ÙŠ*"

        lines = [
            f"ğŸ“– *Ø§Ù„Ø­Ø¯ÙŠØ« Ø±Ù‚Ù… {hid}: {MessageFormatter.esc(hadith['title'])}*{type_badge}",
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€",
            "",
        ]

        # â”€â”€ Ø¥Ø¶Ø§ÙØ© Ø´Ø±Ø­ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø¯Ø³ÙŠ â”€â”€
        if hadith.get("hadith_type") == "qudsi":
            lines.append("ğŸ’ Ù‡Ø°Ø§ Ø­Ø¯ÙŠØ« Ù‚Ø¯Ø³ÙŠ â€” ÙƒÙ„Ø§Ù… Ø§Ù„Ù„Ù‡ ØªØ¹Ø§Ù„Ù‰ Ø¨Ø±ÙˆØ§ÙŠØ© Ø§Ù„Ù†Ø¨ÙŠ ï·º\n")

        # â”€â”€ ÙØµÙ„ Ù…Ù‚Ø¯Ù…Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ Ø¹Ù† Ù†Øµ Ø§Ù„Ø­Ø¯ÙŠØ« â”€â”€
        intro = hadith.get("narrator_intro", "").strip()
        body  = hadith.get("hadith_text_only", "").strip()

        if intro and body:
            lines.append(f"ğŸ—£ï¸ {MessageFormatter.esc(intro)}")
            lines.append("")
            lines.append("ğŸ“œ *Ù‚Ø§Ù„ Ø±Ø³ÙˆÙ„ Ø§Ù„Ù„Ù‡ ï·º:*")
            lines.append(f"Â«{MessageFormatter.esc(body)}Â»")
        else:
            lines.append(f"ğŸ‘¤ *Ø¹Ù† {MessageFormatter.esc(hadith['narrator'])} Ù‚Ø§Ù„:*")
            lines.append(f"Â«{MessageFormatter.esc(hadith['text'])}Â»")

        lines.append("")
        lines.append(f"ğŸ“š *Ø§Ù„Ù…ØµØ¯Ø±:* {MessageFormatter.esc(hadith['source'])}")

        if hadith.get("vocabulary"):
            lines.append("")
            lines.append("ğŸ” *Ù…Ø¹Ø§Ù†ÙŠ Ø§Ù„Ù…ÙØ±Ø¯Ø§Øª:*")
            lines.extend(f"â€¢ {MessageFormatter.esc(str(v))}" for v in hadith["vocabulary"])

        if hadith.get("benefits"):
            lines.append("")
            lines.append("âœ¨ *Ù…Ù† ÙÙˆØ§Ø¦Ø¯ Ø§Ù„Ø­Ø¯ÙŠØ«:*")
            lines.extend(f"â€¢ {MessageFormatter.esc(str(b))}" for b in hadith["benefits"])

        # â”€â”€ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª â”€â”€
        if hadith.get("topics_arabic"):
            topics_str = " Â· ".join(MessageFormatter.esc(str(t)) for t in hadith["topics_arabic"][:5])
            lines.append(f"\nğŸ·ï¸ *Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹:* {topics_str}")

        text = "\n".join(lines)
        keyboard = None

        if include_actions:
            fav_label  = f"{'â­' if is_favorite else 'â˜†'} Ù…ÙØ¶Ù„Ø©"
            note_label = f"ğŸ“ {'ØªØ¹Ø¯ÙŠÙ„' if has_note else 'Ø¥Ø¶Ø§ÙØ©'} Ù…Ù„Ø§Ø­Ø¸Ø©"
            buttons = [
                [
                    InlineKeyboardButton(fav_label,  callback_data=f"fav_{hid}"),
                    InlineKeyboardButton(note_label, callback_data=f"note_{hid}"),
                ],
                [
                    InlineKeyboardButton("ğŸ‘¤ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ",  callback_data=f"narrator_{hid}"),
                    InlineKeyboardButton("ğŸ”— Ø£Ø­Ø§Ø¯ÙŠØ« Ù…Ø±ØªØ¨Ø·Ø©", callback_data=f"related_{hid}"),
                ],
                [
                    InlineKeyboardButton("ğŸ’¬ Ø´Ø±Ø­ Ù…Ø¨Ø³Ø·",      callback_data=f"simple_{hid}"),
                    InlineKeyboardButton("ğŸ“– Ø´Ø±ÙˆØ­Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©", callback_data=f"compare_{hid}"),
                ],
                [
                    InlineKeyboardButton("ğŸŒ Ø§Ù„ØªØ±Ø¬Ù…Ø©",        callback_data=f"english_{hid}"),
                    InlineKeyboardButton("ğŸ“¤ Ù…Ø´Ø§Ø±ÙƒØ©",         callback_data=f"share_{hid}"),
                ],
                [
                    InlineKeyboardButton("ğŸƒ Ø¨Ø·Ø§Ù‚Ø© Ø­ÙØ¸",      callback_data=f"flashcard_{hid}"),
                    InlineKeyboardButton("ğŸ¤” Ø£Ø¹Ø±ÙØŸ",           callback_data=f"selftest_{hid}"),
                ],
                [
                    InlineKeyboardButton("ğŸ’¬ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§",     callback_data="feedback_start"),
                ],
            ]
            keyboard = InlineKeyboardMarkup(buttons)

        return text, keyboard

    @staticmethod
    def build_narrator_card(narrator: Dict[str, Any]) -> str:
        """Ø¨Ù†Ø§Ø¡ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©"""
        name    = narrator.get("arabic", "")
        kunya   = narrator.get("kunya_arabic", "")
        title   = narrator.get("title_arabic", "")
        tribe   = narrator.get("tribe_arabic", "")
        died_ah = narrator.get("died_ah")
        died_ce = narrator.get("died_ce")
        count   = narrator.get("narrations_count")
        bio     = narrator.get("bio_arabic", "")
        paradise = narrator.get("is_ten_promised_paradise", False)
        companion = narrator.get("is_companion", True)

        lines = [f"ğŸ‘¤ *{name}*"]
        if kunya:
            lines.append(f"ğŸ·ï¸ *Ø§Ù„ÙƒÙ†ÙŠØ©:* {kunya}")
        if title:
            lines.append(f"ğŸŒŸ *Ø§Ù„Ù„Ù‚Ø¨:* {title}")
        if tribe:
            lines.append(f"ğŸº *Ø§Ù„Ù‚Ø¨ÙŠÙ„Ø©:* {tribe}")
        lines.append("")

        death_parts = []
        if died_ah:
            death_parts.append(f"{died_ah} Ù‡Ù€")
        if died_ce:
            death_parts.append(f"{died_ce} Ù…")
        if death_parts:
            lines.append(f"ğŸ“… *Ø§Ù„ÙˆÙØ§Ø©:* {' / '.join(death_parts)}")

        if count:
            lines.append(f"ğŸ“œ *Ø¹Ø¯Ø¯ Ù…Ø±ÙˆÙŠØ§ØªÙ‡:* {count:,} Ø­Ø¯ÙŠØ«")

        badges_parts = []
        if companion:
            badges_parts.append("ØµØ­Ø§Ø¨ÙŠ Ø¬Ù„ÙŠÙ„ âœ“")
        if paradise:
            badges_parts.append("â­ Ù…Ù† Ø§Ù„Ø¹Ø´Ø±Ø© Ø§Ù„Ù…Ø¨Ø´Ø±ÙŠÙ† Ø¨Ø§Ù„Ø¬Ù†Ø©")
        if badges_parts:
            lines.append(f"ğŸ… {' | '.join(badges_parts)}")

        if bio:
            lines.append(f"\n{MessageFormatter.esc(bio)}")

        return "\n".join(lines)

    @staticmethod
    def build_english_display(hadith: Dict[str, Any]) -> str:
        """Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ù„Ù„Ø­Ø¯ÙŠØ«"""
        lines = [
            f"ğŸŒ *English â€” Hadith #{hadith['id']}*",
            f"*{MessageFormatter.esc(hadith['title'])}*",
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            "",
        ]
        if hadith.get("english_narrator"):
            lines.append(f"ğŸ—£ï¸ {MessageFormatter.esc(hadith['english_narrator'])}")
            lines.append("")
        if hadith.get("english_text"):
            lines.append(f"ğŸ“œ The Prophet ï·º said:")
            lines.append(f"Â«{MessageFormatter.esc(hadith['english_text'])}Â»")
        lines.append(f"\nğŸ“š *Source:* {hadith.get('source', '')}")
        return "\n".join(lines)

    @staticmethod
    def build_share_text(hadith: Dict[str, Any]) -> str:
        """Ø¨Ù†Ø§Ø¡ Ù†Øµ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© â€” Ø¨Ø¯ÙˆÙ† Markdown Ù„ØªØ¬Ù†Ø¨ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚"""
        body = hadith.get("hadith_text_only") or hadith.get("text", "")
        narrator = hadith.get("narrator", "")
        # Ø¥Ø°Ø§ ÙƒØ§Ù† narrator dictØŒ Ø®Ø° Ø§Ù„Ù†Øµ Ø§Ù„Ø¹Ø±Ø¨ÙŠ
        if isinstance(narrator, dict):
            narrator = narrator.get("arabic", str(narrator))
        source = hadith.get("source", "")
        lines = [
            f"ğŸ“– Ø§Ù„Ø­Ø¯ÙŠØ« Ø±Ù‚Ù… {hadith['id']} Ù…Ù† Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©",
            f"{hadith['title']}",
            "",
            "Ù‚Ø§Ù„ Ø±Ø³ÙˆÙ„ Ø§Ù„Ù„Ù‡ ï·º:",
            f"Â«{body}Â»",
            "",
            f"ğŸ“š Ø¹Ù†: {narrator}",
            f"Ø§Ù„Ù…ØµØ¯Ø±: {source}",
            "",
            "ğŸ“² Ø¹Ø¨Ø± @NibrasNawawi_bot",
        ]
        return "\n".join(lines)

    @staticmethod
    def build_hadith_list(hadiths: List[Dict[str, Any]]) -> str:
        lines = ["ğŸ“š *ÙÙ‡Ø±Ø³ Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©:*", ""]
        for h in hadiths:
            badge = " âœ¨" if h.get("hadith_type") == "qudsi" else ""
            lines.append(f"Ø§Ù„Ø­Ø¯ÙŠØ« {h['id']}: {h['title']}{badge}")
        return "\n".join(lines)

    @staticmethod
    def build_search_results(results: List[Dict[str, Any]], keyword: str) -> str:
        if not results:
            suggestions = [
                "â€¢ ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„ØµØ­ÙŠØ­",
                "â€¢ Ø¬Ø±Ø¨ ÙƒÙ„Ù…Ø© Ø£Ù‚ØµØ± Ø£Ùˆ Ù…Ø±Ø§Ø¯ÙØ§Ù‹",
                "â€¢ Ù…Ø«Ø§Ù„: Ø§Ù„Ù†ÙŠØ©ØŒ Ø§Ù„ØµÙ„Ø§Ø©ØŒ Ø§Ù„Ø¥ÙŠÙ…Ø§Ù†",
            ]
            return (
                f"ğŸ” Ù„Ù… Ø£Ø¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø« Ø¹Ù†: *{MessageFormatter.esc(keyword)}*\n\n"
                "ğŸ’¡ *Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª:*\n" + "\n".join(suggestions)
            )

        # Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù†Øµ Ù…Ø¹ ØªÙ…ÙŠÙŠØ² Ø§Ù„ÙƒÙ„Ù…Ø©
        def preview(hadith: Dict[str, Any], kw: str) -> str:
            text = hadith.get("text", "")
            kw_l = kw.lower()
            idx  = text.lower().find(kw_l)
            if idx == -1:
                # Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
                return ""
            start = max(0, idx - 30)
            end   = min(len(text), idx + len(kw) + 50)
            snippet = ("..." if start > 0 else "") + text[start:end] + ("..." if end < len(text) else "")
            return f"\n   _{MessageFormatter.esc(snippet)}_"

        total = len(results)
        lines = [
            f"ğŸ” *Ù†ØªØ§Ø¦Ø¬: Â«{MessageFormatter.esc(keyword)}Â»*",
            f"ğŸ“Š {total} Ù†ØªÙŠØ¬Ø© Ù…Ø±ØªØ¨Ø© Ø­Ø³Ø¨ Ø§Ù„ØµÙ„Ø©:",
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€",
        ]

        for h in results[:15]:  # Ø¹Ø±Ø¶ Ø£ÙˆÙ„ 15 Ù†ØªÙŠØ¬Ø©
            badge   = " âœ¨" if h.get("hadith_type") == "qudsi" else ""
            topics  = h.get("topics_arabic", [])
            tag     = f" â€¢ _{MessageFormatter.esc(topics[0])}_" if topics else ""
            snip    = preview(h, keyword)
            lines.append(
                f"\n*{h['id']}.* {MessageFormatter.esc(h['title'])}{badge}{tag}{snip}"
            )

        if total > 15:
            lines.append(f"\n_... Ùˆ {total - 15} Ù†ØªÙŠØ¬Ø© Ø£Ø®Ø±Ù‰ØŒ Ø®ØµÙ‘Øµ Ø¨Ø­Ø«Ùƒ Ø£ÙƒØ«Ø±_")

        lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡ ÙƒØ§Ù…Ù„Ø§Ù‹")
        return "\n".join(lines)

    @staticmethod
    def build_statistics(stats: Dict[str, Any]) -> str:
        progress = stats["progress_percentage"]
        filled   = int(progress / 10)
        bar      = "â–°" * filled + "â–±" * (10 - filled)

        # Ø´Ø±ÙŠØ· Ø§Ù„Ø³Ù„Ø³Ù„Ø©
        streak       = stats.get("streak", 0)
        streak_best  = stats.get("streak_best", 0)
        streak_fire  = "ğŸ”¥" * min(streak, 5)

        # Ø§Ù„Ø´Ø§Ø±Ø§Øª
        earned = stats.get("earned_badges", [])
        badges_str = " ".join(BADGES[b]["emoji"] for b in earned if b in BADGES) if earned else "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø¹Ø¯"

        # Ø£Ø³Ø¨ÙˆØ¹
        week_reads = stats.get("week_reads", 0)

        lines = [
            "ğŸ“Š *Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ ÙÙŠ Ù†Ø¨Ø±Ø§Ø³*",
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€",
            "",
            "*ğŸ—“ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹:*",
            f"â€¢ ğŸ“– Ù‚Ø±Ø£Øª {week_reads} Ø­Ø¯ÙŠØ«Ø§Ù‹",
            f"â€¢ ğŸ”¥ Ø§Ù„Ø³Ù„Ø³Ù„Ø©: {streak} ÙŠÙˆÙ… Ù…ØªÙˆØ§ØµÙ„ {streak_fire}",
            f"â€¢ ğŸ† Ø£Ø¹Ù„Ù‰ Ø³Ù„Ø³Ù„Ø©: {streak_best} ÙŠÙˆÙ…",
            "",
            "*ğŸ“ˆ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:*",
            f"â€¢ ğŸ“– Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø©: {stats['read_hadiths']}/{stats['total_hadiths']}",
            f"â€¢ ğŸ“Š Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²: {progress}%",
            f"â€¢ â­ Ø§Ù„Ù…ÙØ¶Ù„Ø©: {stats['favorites']} Ø­Ø¯ÙŠØ«",
            f"â€¢ ğŸ“ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª: {stats['notes']}",
            "",
            f"*ğŸ“ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª:*",
            f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª: {stats['quizzes_taken']}",
            f"â€¢ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {stats['average_quiz_score']}%",
            f"â€¢ Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: {stats['best_quiz_score']}%",
            "",
            f"*ğŸƒ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸:* {stats.get('flashcard_count', 0)} Ù…Ø±Ø§Ø¬Ø¹Ø©",
            f"*ğŸ“‹ ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©:* {stats.get('needs_review', 0)} Ø­Ø¯ÙŠØ«",
            "",
            f"Ø§Ù„ØªÙ‚Ø¯Ù…: {bar} {progress}%",
            "",
            f"ğŸ… *Ø´Ø§Ø±Ø§ØªÙƒ:* {badges_str}",
        ]
        return "\n".join(lines)

    @staticmethod
    def build_categories_menu(categories: Dict[str, List[int]]) -> Tuple[str, InlineKeyboardMarkup]:
        """Ø¨Ù†Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©"""
        text = "ğŸ·ï¸ *ØªØµÙØ­ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø¨Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹*\n\nØ§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹:"
        buttons = []
        for cat, ids in sorted(categories.items(), key=lambda x: len(x[1]), reverse=True):
            label = f"{cat} ({len(ids)})"
            cb    = f"cat_{cat[:28]}"  # 28 Ø­Ø±Ù Ã— 2 bytes + 4 = 60 bytes < 64
            buttons.append([InlineKeyboardButton(label, callback_data=cb)])
        buttons.append([InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="start")])
        return text, InlineKeyboardMarkup(buttons)

    @staticmethod
    def build_flashcard(hadith: Dict[str, Any], show_answer: bool = False) -> Tuple[str, InlineKeyboardMarkup]:
        """Ø¨Ù†Ø§Ø¡ Ø¨Ø·Ø§Ù‚Ø© Ø­ÙØ¸ ØªÙØ§Ø¹Ù„ÙŠØ©"""
        hid  = hadith["id"]
        body = hadith.get("hadith_text_only") or hadith.get("text", "")

        if not show_answer:
            text = (
                f"ğŸƒ *Ø¨Ø·Ø§Ù‚Ø© Ø­ÙØ¸ â€” Ø§Ù„Ø­Ø¯ÙŠØ« {hid}*\n"
                f"*{MessageFormatter.esc(hadith['title'])}*\n\n"
                "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                f"Â«{MessageFormatter.esc(body[:200])}Â»\n\n"
                "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                "_Ù‡Ù„ ØªØ¹Ø±Ù Ø±Ø§ÙˆÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ« ÙˆÙ…ØµØ¯Ø±Ù‡ØŸ_"
            )
            buttons = [
                [
                    InlineKeyboardButton("ğŸ” Ø§ÙƒØ´Ù Ø§Ù„Ø±Ø§ÙˆÙŠ",  callback_data=f"fc_reveal_{hid}"),
                ],
                [
                    InlineKeyboardButton("âœ… Ø­ÙØ¸ØªÙ‡!",        callback_data=f"fc_know_{hid}"),
                    InlineKeyboardButton("â“ Ù„Ø§ Ø£ØªØ°ÙƒØ±Ù‡",     callback_data=f"fc_dontknow_{hid}"),
                ],
                [InlineKeyboardButton("â­ï¸ ØªØ®Ø·Ù‰",            callback_data=f"fc_skip_{hid}")],
                [InlineKeyboardButton("ğŸšª Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©",   callback_data="fc_end")],
            ]
        else:
            text = (
                f"ğŸƒ *Ø§Ù„Ø­Ø¯ÙŠØ« {hid}: {MessageFormatter.esc(hadith['title'])}*\n\n"
                f"ğŸ“œ Â«{MessageFormatter.esc(body[:200])}Â»\n\n"
                f"ğŸ‘¤ *Ø§Ù„Ø±Ø§ÙˆÙŠ:* {MessageFormatter.esc(hadith['narrator'])}\n"
                f"ğŸ“š *Ø§Ù„Ù…ØµØ¯Ø±:* {MessageFormatter.esc(hadith['source'])}\n\n"
                "_Ù‡Ù„ Ø­ÙØ¸ØªÙ‡ØŸ_"
            )
            buttons = [
                [
                    InlineKeyboardButton("âœ… Ù†Ø¹Ù…ØŒ Ø­ÙØ¸ØªÙ‡!",   callback_data=f"fc_know_{hid}"),
                    InlineKeyboardButton("â“ Ù„Ø§ Ø¨Ø¹Ø¯",         callback_data=f"fc_dontknow_{hid}"),
                ],
                [InlineKeyboardButton("ğŸšª Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©",   callback_data="fc_end")],
            ]
        return text, InlineKeyboardMarkup(buttons)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 8. Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class QuizSystem:
    active_quizzes: Dict[int, Dict[str, Any]] = {}
    _TYPE_EMOJI = {"narrator": "ğŸ‘¤", "title": "ğŸ“–", "completion": "âœï¸", "source": "ğŸ“š"}

    @classmethod
    def generate_quiz(cls, hadith_db: HadithDatabase, question_count: int = 5) -> List[Dict[str, Any]]:
        all_hadiths   = hadith_db.get_all()
        question_count = min(question_count, len(all_hadiths))
        selected      = random.sample(all_hadiths, question_count)
        questions: List[Dict[str, Any]] = []
        types = ["narrator", "title", "completion", "source"]
        for hadith in selected:
            q_type   = random.choice(types)
            question = cls._make_question(q_type, hadith, all_hadiths)
            if not cls._is_valid(question):
                question = cls._make_narrator_q(hadith, all_hadiths)
            if cls._is_valid(question):
                questions.append(question)
        return questions

    @classmethod
    def _make_question(cls, q_type: str, hadith: Dict[str, Any], all_hadiths: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if q_type == "narrator":
            return cls._make_narrator_q(hadith, all_hadiths)
        elif q_type == "title":
            return cls._make_title_q(hadith, all_hadiths)
        elif q_type == "completion":
            return cls._make_completion_q(hadith, all_hadiths)
        else:
            return cls._make_source_q(hadith, all_hadiths)

    @staticmethod
    def _build_options(correct: str, pool: List[str], count: int = 3) -> List[str]:
        others = [x for x in set(pool) if x != correct]
        random.shuffle(others)
        opts = [correct] + others[:count]
        random.shuffle(opts)
        return opts

    @classmethod
    def _make_narrator_q(cls, h: Dict[str, Any], all_h: List[Dict[str, Any]]) -> Dict[str, Any]:
        correct = h["narrator"]
        pool = [x["narrator"] for x in all_h] + [
            "Ø£Ø¨Ùˆ Ù‡Ø±ÙŠØ±Ø©", "Ø¹Ù…Ø± Ø¨Ù† Ø§Ù„Ø®Ø·Ø§Ø¨", "Ø¹Ø§Ø¦Ø´Ø©",
            "Ø£Ù†Ø³ Ø¨Ù† Ù…Ø§Ù„Ùƒ", "Ø§Ø¨Ù† Ø¹Ø¨Ø§Ø³", "Ø£Ø¨Ùˆ Ø³Ø¹ÙŠØ¯ Ø§Ù„Ø®Ø¯Ø±ÙŠ",
        ]
        return {"hadith_id": h["id"], "question": f"Ù…Ù† Ø±Ø§ÙˆÙŠ Ø§Ù„Ø­Ø¯ÙŠØ«: *{MessageFormatter.esc(h['title'])}*ØŸ",
                "options": cls._build_options(correct, pool), "correct_answer": correct, "type": "narrator"}

    @classmethod
    def _make_title_q(cls, h: Dict[str, Any], all_h: List[Dict[str, Any]]) -> Dict[str, Any]:
        correct = h["title"]
        pool    = [x["title"] for x in all_h]
        preview = h["text"][:80] + ("..." if len(h["text"]) > 80 else "")
        return {"hadith_id": h["id"], "question": f"Ù…Ø§ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø°ÙŠ ÙŠØ¨Ø¯Ø£ Ø¨Ù€:\nÂ«{MessageFormatter.esc(preview)}Â»",
                "options": cls._build_options(correct, pool), "correct_answer": correct, "type": "title"}

    @classmethod
    def _make_completion_q(cls, h: Dict[str, Any], all_h: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        words = h["text"].split()
        if len(words) < 15:
            return None
        cut        = random.randint(len(words) // 3, len(words) // 2)
        first_part = " ".join(words[:cut])
        correct    = " ".join(words[cut:cut + 5])
        pool: List[str] = []
        for other in all_h:
            if other["id"] == h["id"]:
                continue
            ow = other["text"].split()
            if len(ow) < 5:
                continue
            si    = random.randint(0, len(ow) - 5)
            chunk = " ".join(ow[si:si + 5])
            if chunk != correct:
                pool.append(chunk)
            if len(pool) >= 10:
                break
        pool.extend(["ÙˆØ§Ù„Ù„Ù‡ Ø£Ø¹Ù„Ù… Ø¨Ø°Ù„Ùƒ", "ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±", "Ø¥Ù† Ø§Ù„Ù„Ù‡ ØºÙÙˆØ± Ø±Ø­ÙŠÙ…"])
        return {"hadith_id": h["id"], "question": f"Ø£ÙƒÙ…Ù„ Ø§Ù„Ø­Ø¯ÙŠØ«:\nÂ«{MessageFormatter.esc(first_part)}... Â»",
                "options": cls._build_options(correct, pool), "correct_answer": correct, "type": "completion"}

    @classmethod
    def _make_source_q(cls, h: Dict[str, Any], all_h: List[Dict[str, Any]]) -> Dict[str, Any]:
        correct = h["source"]
        pool = [x["source"] for x in all_h] + [
            "ØµØ­ÙŠØ­ Ø§Ù„Ø¨Ø®Ø§Ø±ÙŠ", "ØµØ­ÙŠØ­ Ù…Ø³Ù„Ù…", "Ø³Ù†Ù† Ø£Ø¨ÙŠ Ø¯Ø§ÙˆØ¯",
            "Ø³Ù†Ù† Ø§Ù„ØªØ±Ù…Ø°ÙŠ", "Ø³Ù†Ù† Ø§Ù„Ù†Ø³Ø§Ø¦ÙŠ", "Ø³Ù†Ù† Ø§Ø¨Ù† Ù…Ø§Ø¬Ù‡",
        ]
        return {"hadith_id": h["id"], "question": f"Ù…Ø§ Ù…ØµØ¯Ø± Ø§Ù„Ø­Ø¯ÙŠØ«: *{MessageFormatter.esc(h['title'])}*ØŸ",
                "options": cls._build_options(correct, pool), "correct_answer": correct, "type": "source"}

    @staticmethod
    def _is_valid(q: Optional[Dict[str, Any]]) -> bool:
        if not q:
            return False
        if not all(f in q for f in ("question", "options", "correct_answer", "type")):
            return False
        if len(q["options"]) < 2:
            return False
        if q["correct_answer"] not in q["options"]:
            return False
        return True

    @classmethod
    def start(cls, user_id: int, questions: List[Dict[str, Any]]) -> None:
        cls.active_quizzes[user_id] = {"questions": questions, "current_index": 0, "score": 0, "answers": []}

    @classmethod
    def get_current_question(cls, user_id: int) -> Optional[Dict[str, Any]]:
        quiz = cls.active_quizzes.get(user_id)
        if not quiz:
            return None
        idx = quiz["current_index"]
        return quiz["questions"][idx] if idx < len(quiz["questions"]) else None

    @classmethod
    def submit_answer(cls, user_id: int, answer: str) -> Tuple[bool, Optional[str]]:
        quiz = cls.active_quizzes.get(user_id)
        if not quiz:
            return False, None
        question   = quiz["questions"][quiz["current_index"]]
        is_correct = answer == question.get("correct_answer")
        if is_correct:
            quiz["score"] += 1
        quiz["answers"].append({
            "question_id":    quiz["current_index"],
            "user_answer":    answer,
            "correct_answer": question.get("correct_answer"),
            "is_correct":     is_correct,
        })
        quiz["current_index"] += 1
        return is_correct, question.get("correct_answer")

    @classmethod
    def get_result(cls, user_id: int) -> Optional[Dict[str, Any]]:
        quiz = cls.active_quizzes.pop(user_id, None)
        if not quiz:
            return None
        total = len(quiz["questions"])
        score = quiz["score"]
        return {"score": score, "total": total, "percentage": round((score / total) * 100, 2) if total else 0, "answers": quiz["answers"]}

    @classmethod
    def is_active(cls, user_id: int) -> bool:
        return user_id in cls.active_quizzes

    @classmethod
    def cancel(cls, user_id: int) -> None:
        cls.active_quizzes.pop(user_id, None)

    @staticmethod
    def build_result_text(result: Dict[str, Any]) -> str:
        pct = result["percentage"]
        if pct >= 90:
            grade, emoji = "Ù…Ù…ØªØ§Ø²! ğŸ†", "ğŸŒŸ"
        elif pct >= 70:
            grade, emoji = "Ø¬ÙŠØ¯ Ø¬Ø¯Ø§Ù‹! ğŸ‘", "âœ¨"
        elif pct >= 50:
            grade, emoji = "Ø¬ÙŠØ¯! ğŸ‘", "ğŸ’ª"
        else:
            grade, emoji = "ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ† ğŸ“š", "ğŸ’¡"
        return (
            f"{emoji} *Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±*\n"
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n\n"
            f"âœ… Ø§Ù„ØµØ­ÙŠØ­: {result['score']}/{result['total']}\n"
            f"ğŸ“Š Ø§Ù„Ù†Ø³Ø¨Ø©: {pct}%\n"
            f"ğŸ¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: {grade}\n\n"
            "ğŸ’ª Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„ØªØ¹Ù„Ù…!"
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 9. Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (Ù…Ø­Ø³Ù‘Ù† Ø¨Ø³ÙŠØ§Ù‚ Ø§Ù„Ø­Ø¯ÙŠØ«)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class NibrasAI:
    OPENROUTER_URL   = "https://openrouter.ai/api/v1/chat/completions"
    OPENROUTER_MODEL = "google/gemini-2.0-flash-001"
    GOOGLE_URL       = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent"

    _PROMPTS = {
        "normal": (
            "Ø£Ù†Øª 'Ù†Ø¨Ø±Ø§Ø³'ØŒ Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ù…ØªØ®ØµØµ Ø­ØµØ±ÙŠØ§Ù‹ ÙÙŠ Ø´Ø±Ø­ ÙˆØªÙØ³ÙŠØ± 'Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©'.\n"
            "ØªØªÙ…ÙŠØ² Ø¨Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø¹Ù„Ù…ÙŠØ©ØŒ Ø§Ù„ÙˆØ¶ÙˆØ­ØŒ Ø§Ù„ÙˆÙ‚Ø§Ø±ØŒ ÙˆØ§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ.\n\n"
            "âš ï¸ ÙÙŠ Ù†Ù‡Ø§ÙŠØ© ÙƒÙ„ Ø±Ø¯ Ø§Ù‚ØªØ±Ø­ Ø³Ø¤Ø§Ù„Ø§Ù‹ ÙˆØ§Ø­Ø¯Ø§Ù‹ Ø°ÙƒÙŠØ§Ù‹ Ø¨ÙŠÙ† ## ##\n"
            "Ù…Ø«Ø§Ù„: ##Ù…Ø§ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ« ÙˆØ§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø³Ø§Ø¨Ø¹ØŸ##"
        ),
        "simple": (
            "Ø£Ù†Øª Ù…Ø¹Ù„Ù… ØµØ¨ÙˆØ± ÙŠØ´Ø±Ø­ Ù„Ù„Ø£Ø·ÙØ§Ù„ ÙˆØ§Ù„Ù…Ø¨ØªØ¯Ø¦ÙŠÙ†.\n"
            "Ø§Ø´Ø±Ø­ Ø¨Ù„ØºØ© Ø¨Ø³ÙŠØ·Ø© Ù…Ø¹ Ø£Ù…Ø«Ù„Ø© Ù…Ù† Ø§Ù„Ø­ÙŠØ§Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© ÙˆØ¬Ù…Ù„ Ù‚ØµÙŠØ±Ø©.\n"
            "ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø§Ù‚ØªØ±Ø­ Ø³Ø¤Ø§Ù„Ø§Ù‹ Ù…Ù†Ø§Ø³Ø¨Ø§Ù‹ Ø¨ÙŠÙ† ## ##"
        ),
        "compare": (
            "Ø£Ù†Øª Ø¹Ø§Ù„Ù… ÙŠÙ‚Ø¯Ù… Ø´Ø±ÙˆØ­Ø§Ù‹ Ù…Ù‚Ø§Ø±Ù†Ø© Ù„Ù„Ø£Ø­Ø§Ø¯ÙŠØ«:\n"
            "1. Ø§Ù„ÙÙ‡Ù… Ø§Ù„Ù„ØºÙˆÙŠ  2. Ø§Ù„Ø´Ø±Ø­ Ø§Ù„ÙÙ‚Ù‡ÙŠ  3. Ø§Ù„Ø¬ÙˆØ§Ù†Ø¨ Ø§Ù„Ø£Ø®Ù„Ø§Ù‚ÙŠØ©  4. Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø¹Ø§ØµØ±\n"
            "ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø§Ù‚ØªØ±Ø­ Ø³Ø¤Ø§Ù„Ø§Ù‹ Ø¹Ù…ÙŠÙ‚Ø§Ù‹ Ø¨ÙŠÙ† ## ##"
        ),
    }

    def __init__(self, openrouter_key: str, google_key: Optional[str], memory: ConversationMemory) -> None:
        self.openrouter_key = openrouter_key
        self.google_key     = google_key
        self.memory         = memory

    async def generate_response(
        self,
        user_id: int,
        user_message: str,
        additional_context: str = "",
        mode: str = "normal",
        active_hadith: Optional[Dict[str, Any]] = None,
    ) -> str:
        messages = self._build_messages(user_id, user_message, additional_context, mode, active_hadith)

        if self.google_key:
            try:
                text = await self._call_google(messages)
                self._store(user_id, user_message, text)
                return text
            except Exception as exc:
                logger.warning(f"âš ï¸ ÙØ´Ù„ Google AI: {exc}")

        try:
            text = await self._call_openrouter(messages)
            self._store(user_id, user_message, text)
            return text
        except Exception as exc:
            logger.error(f"âŒ ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: {exc}")
            return self._fallback()

    def _store(self, user_id: int, user_msg: str, ai_msg: str) -> None:
        self.memory.add_message(user_id, "user",      user_msg)
        self.memory.add_message(user_id, "assistant", ai_msg)

    def _build_messages(self, user_id: int, msg: str, context: str, mode: str, active_hadith: Optional[Dict[str, Any]]) -> List[Dict[str, str]]:
        prompt = self._PROMPTS.get(mode, self._PROMPTS["normal"])
        if context:
            prompt += f"\n\n{context}"
        # â† ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø³ÙŠØ§Ù‚: Ø£Ø®Ø¨Ø± AI Ø¨Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ù…Ù†Ø§Ù‚ÙØ´
        if active_hadith:
            prompt += (
                f"\n\nğŸ“Œ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ù…Ù†Ø§Ù‚ÙØ´ Ø­Ø§Ù„ÙŠØ§Ù‹:\n"
                f"Ø§Ù„Ø±Ù‚Ù…: {active_hadith['id']} â€” {active_hadith['title']}\n"
                f"Ø§Ù„Ø±Ø§ÙˆÙŠ: {active_hadith['narrator']}\n"
                f"Ø§Ù„Ù†Øµ: {active_hadith['text'][:400]}"
            )
        messages = [{"role": "system", "content": prompt}]
        messages.extend(self.memory.get(user_id))
        messages.append({"role": "user", "content": msg})
        return messages

    async def _call_google(self, messages: List[Dict[str, str]]) -> str:
        prompt = "\n\n".join(f"{m['role']}: {m['content']}" for m in messages)
        url    = f"{self.GOOGLE_URL}?key={self.google_key}"
        async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
            resp = await client.post(url, json={"contents": [{"parts": [{"text": prompt}]}]})
            resp.raise_for_status()
            return resp.json()["candidates"][0]["content"]["parts"][0]["text"]

    async def _call_openrouter(self, messages: List[Dict[str, str]]) -> str:
        headers = {"Authorization": f"Bearer {self.openrouter_key}", "Content-Type": "application/json"}
        payload = {"model": self.OPENROUTER_MODEL, "messages": messages}
        async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
            resp = await client.post(self.OPENROUTER_URL, headers=headers, json=payload)
            resp.raise_for_status()
            return resp.json()["choices"][0]["message"]["content"]

    @staticmethod
    def _fallback() -> str:
        return (
            "ğŸ˜” Ø£Ø¹ØªØ°Ø±ØŒ ÙˆØ§Ø¬Ù‡Øª ØµØ¹ÙˆØ¨Ø© ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ Ø­Ø§Ù„ÙŠØ§Ù‹.\n\n"
            "ğŸ’¡ *ÙŠÙ…ÙƒÙ†Ùƒ:*\n"
            "â€¢ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø¯Ù‚Ø§Ø¦Ù‚\n"
            "â€¢ Ø§Ø³ØªØ®Ø¯Ø§Ù… `/list` Ù„ØªØµÙØ­ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«\n"
            "â€¢ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù…Ø¨Ø§Ø´Ø±Ø©\n\n"
            "_Ø³Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù‚Ø±ÙŠØ¨Ø§Ù‹_ ğŸ”§"
        )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 10. Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¨ÙˆØª (Ø§Ù„ÙƒØ§Ù…Ù„Ø©)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø´Ø±Ù
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def is_admin(user_id: int) -> bool:
    """ØªØ­Ù‚Ù‚ Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ø§Ù„Ù…Ø´Ø±Ù"""
    dev_id = os.getenv("DEVELOPER_TELEGRAM_ID", "")
    return dev_id and str(user_id) == str(dev_id)


def admin_only(func):
    """Decorator ÙŠÙ…Ù†Ø¹ ØºÙŠØ± Ø§Ù„Ù…Ø´Ø±Ù Ù…Ù† ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±"""
    import functools
    @functools.wraps(func)
    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if not is_admin(update.effective_user.id):
            await update.message.reply_text("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·.")
            return
        return await func(self, update, context)
    return wrapper

class BotHandlers:
    """Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£ÙˆØ§Ù…Ø± ÙˆØ±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¨ÙˆØª â€” Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© v3"""

    _WELCOME_TEXT = (
        "ğŸŒŸ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¨Ø±Ø§Ø³*\n"
        "_Ù…Ø¹Ù„Ù‘Ù…Ùƒ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©_\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "*ğŸ“š Ù…Ø§ Ø§Ù„Ø°ÙŠ ÙŠÙ…ÙƒÙ†Ù†ÙŠ ÙØ¹Ù„Ù‡ØŸ*\n\n"
        "ğŸ” Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„Ø§Ø³ØªÙƒØ´Ø§Ù Ø¨Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª\n"
        "ğŸ’¬ Ø´Ø±Ø­ ÙˆØªÙØ³ÙŠØ± Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ\n"
        "ğŸ“ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ØªÙØ§Ø¹Ù„ÙŠØ© Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹\n"
        "ğŸƒ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©\n"
        "ğŸ‘¤ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©\n"
        "ğŸŒ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n"
        "ğŸ† Ù†Ø¸Ø§Ù… Ø§Ù„Ø´Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª\n"
        "ğŸ”¥ Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª\n"
        "â­ Ù…ÙØ¶Ù„Ø© ÙˆÙ…Ù„Ø§Ø­Ø¸Ø§Øª Ø´Ø®ØµÙŠØ©\n"
        "ğŸ¯ Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ© Ù…Ù†Ø¸Ù…Ø©\n"
        "â° ØªØ°ÙƒÙŠØ± ÙŠÙˆÙ…ÙŠ ÙˆÙ…Ø³Ø§Ø¦ÙŠ\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "*ğŸš€ Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†:*\n"
        "â€¢ Ø§Ø¶ØºØ· Ø£ÙŠ Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡\n"
        "â€¢ Ø£Ùˆ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« (1-42)\n"
        "â€¢ Ø£Ùˆ Ø§Ø·Ø±Ø­ Ø£ÙŠ Ø³Ø¤Ø§Ù„ Ù†ØµÙŠ!"
    )

    _HELP_TEXT = (
        "ğŸ“– *Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¨Ø±Ø§Ø³ v3*\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "*ğŸ“š Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«:*\n"
        "/list â€” ÙÙ‡Ø±Ø³ Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø­Ø¯ÙŠØ«Ø§Ù‹\n"
        "/random â€” Ø­Ø¯ÙŠØ« Ø¹Ø´ÙˆØ§Ø¦ÙŠ\n"
        "/daily â€” Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…\n"
        "/topics â€” ØªØµÙØ­ Ø¨Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª\n"
        "/search ÙƒÙ„Ù…Ø© â€” Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«\n"
        "Ø£Ùˆ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù…Ø§Ù‹ Ù…Ù† 1 Ø¥Ù„Ù‰ 42 Ù…Ø¨Ø§Ø´Ø±Ø©\n\n"
        "*ğŸ“ Ø§Ù„ØªØ¹Ù„Ù…:*\n"
        "/quiz â€” Ø§Ø®ØªØ¨Ø§Ø± ØªÙØ§Ø¹Ù„ÙŠ\n"
        "/flashcard â€” Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸\n"
        "/selftest â€” Ø£Ø¹Ø±Ù / Ù„Ø§ Ø£Ø¹Ø±Ù\n"
        "/plan â€” Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ© Ù…Ù†Ø¸Ù…Ø©\n\n"
        "*ğŸ“Š Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©:*\n"
        "/stats â€” Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ ÙˆØ´Ø§Ø±Ø§ØªÙŠ\n"
        "/badges â€” Ø´Ø§Ø±Ø§ØªÙŠ ÙˆØ§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª\n"
        "/favorites â€” Ø£Ø­Ø§Ø¯ÙŠØ«ÙŠ Ø§Ù„Ù…ÙØ¶Ù„Ø©\n"
        "/review â€” Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©\n\n"
        "*â° Ø§Ù„ØªØ°ÙƒÙŠØ±:*\n"
        "/reminder â€” Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ°ÙƒÙŠØ±\n"
        "/reminder on 08:00 â€” ØªÙØ¹ÙŠÙ„ ØµØ¨Ø§Ø­ÙŠ\n"
        "/reminder evening 22:00 â€” ØªÙØ¹ÙŠÙ„ Ù…Ø³Ø§Ø¦ÙŠ\n"
        "/reminder off â€” ØªØ¹Ø·ÙŠÙ„\n\n"
        "*ğŸ’¬ Ø£Ø®Ø±Ù‰:*\n"
        "/feedback â€” ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±\n"
        "/cancel â€” Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©\n\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "*ğŸ’¡ Ù†ØµÙŠØ­Ø©:* Ø§Ø·Ø±Ø­ Ø£ÙŠ Ø³Ø¤Ø§Ù„ Ù†ØµÙŠ\n"
        "ÙˆØ³Ø£Ø¬ÙŠØ¨Ùƒ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ! ğŸ¤–"
    )

    def __init__(
        self,
        hadith_db:     HadithDatabase,
        user_data_mgr: UserDataManager,
        ai_engine:     NibrasAI,
        formatter:     MessageFormatter,
    ) -> None:
        self.db        = hadith_db
        self.user_data = user_data_mgr
        self.ai        = ai_engine
        self.fmt       = formatter

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø®Ø§ØµØ©
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def _main_keyboard(self) -> InlineKeyboardMarkup:
        return InlineKeyboardMarkup([
            [
                InlineKeyboardButton("ğŸ“š Ø§Ù„ÙÙ‡Ø±Ø³",          callback_data="list"),
                InlineKeyboardButton("ğŸŒ€ Ø¹Ø´ÙˆØ§Ø¦ÙŠ",          callback_data="random"),
            ],
            [
                InlineKeyboardButton("ğŸ“… Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…",      callback_data="daily"),
                InlineKeyboardButton("ğŸ·ï¸ Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹",    callback_data="topics"),
            ],
            [
                InlineKeyboardButton("ğŸ“ Ø§Ø®ØªØ¨Ø§Ø±",          callback_data="quiz"),
                InlineKeyboardButton("ğŸƒ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸",    callback_data="flashcard_start"),
            ],
            [
                InlineKeyboardButton("ğŸ¤” Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù",   callback_data="selftest_start"),
                InlineKeyboardButton("ğŸ¯ Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ©",      callback_data="plan"),
            ],
            [
                InlineKeyboardButton("ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ",       callback_data="stats"),
                InlineKeyboardButton("ğŸ… Ø´Ø§Ø±Ø§ØªÙŠ",          callback_data="badges"),
            ],
            [
                InlineKeyboardButton("â­ Ø§Ù„Ù…ÙØ¶Ù„Ø©",         callback_data="favorites"),
                InlineKeyboardButton("â° Ø§Ù„ØªØ°ÙƒÙŠØ±",         callback_data="reminder_menu"),
            ],
            [
                InlineKeyboardButton("ğŸ’¬ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§",      callback_data="feedback_start"),
                SupportSystem.get_button(),
            ],
            [InlineKeyboardButton("â“ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©",   callback_data="help")],
        ])

    def _plan_choice_keyboard(self) -> InlineKeyboardMarkup:
        return InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ“… 7 Ø£ÙŠØ§Ù… (6 Ø£Ø­Ø§Ø¯ÙŠØ«/ÙŠÙˆÙ…)",  callback_data="plan_7")],
            [InlineKeyboardButton("ğŸ“… 14 ÙŠÙˆÙ… (3 Ø£Ø­Ø§Ø¯ÙŠØ«/ÙŠÙˆÙ…)", callback_data="plan_14")],
            [InlineKeyboardButton("ğŸ“… 21 ÙŠÙˆÙ… (2 Ø­Ø¯ÙŠØ«/ÙŠÙˆÙ…)",   callback_data="plan_21")],
            [InlineKeyboardButton("ğŸ“… 42 ÙŠÙˆÙ… (Ø­Ø¯ÙŠØ«/ÙŠÙˆÙ…)",     callback_data="plan_42")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",               callback_data="start")],
        ])

    async def _display_hadith(self, user_id: int, hadith: Dict[str, Any], status_message, prefix: str = "") -> None:
        """Ø¹Ø±Ø¶ Ø­Ø¯ÙŠØ« ÙƒØ§Ù…Ù„ Ù…Ø¹ ØªØ³Ø¬ÙŠÙ„Ù‡ Ù…Ù‚Ø±ÙˆØ¡Ø§Ù‹ + Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©"""
        self.user_data.mark_as_read(user_id, hadith["id"])
        self.ai.memory.set_active_hadith(user_id, hadith["id"])

        is_fav  = self.user_data.is_favorite(user_id, hadith["id"])
        has_note = self.user_data.get_note(user_id, hadith["id"]) is not None

        body, keyboard = self.fmt.build_hadith_display(
            hadith, include_actions=True, is_favorite=is_fav, has_note=has_note
        )
        questions_text = SmartQuestionSystem.format_message(hadith)
        final = (prefix + body + questions_text).strip()

        if len(final) > 4096:
            final = final[:4093] + "..."

        await status_message.edit_text(final, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø´Ø§Ø±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙˆØ¥Ø®Ø¨Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        new_badges = self.user_data.check_and_award_badges(user_id)
        if new_badges:
            badges_text = "\n".join(
                f"{BADGES[b]['emoji']} *{BADGES[b]['name']}* â€” {BADGES[b]['desc']}"
                for b in new_badges if b in BADGES
            )
            await status_message.reply_text(
                f"ğŸ‰ *Ù…Ø¨Ø±ÙˆÙƒ! Ø­ØµÙ„Øª Ø¹Ù„Ù‰ Ø´Ø§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©!*\n\n{badges_text}",
                parse_mode=ParseMode.MARKDOWN,
            )

    async def _send_support_if_due(self, chat_id: int, bot) -> None:
        if self.user_data.should_show_support_reminder(chat_id):
            self.user_data.update_support_reminder(chat_id)
            await bot.send_message(
                chat_id=chat_id,
                text=SupportSystem.get_message(),
                reply_markup=InlineKeyboardMarkup([[SupportSystem.get_button()]]),
                parse_mode=ParseMode.MARKDOWN,
            )

    async def _handle_hadith_by_number(self, update: Update, number: str, user_id: int) -> None:
        hadith_id = int(number)
        hadith    = self.db.get_by_id(hadith_id)
        if not hadith:
            await update.message.reply_text(
                f"âŒ Ù„Ù… Ø£Ø¬Ø¯ Ø§Ù„Ø­Ø¯ÙŠØ« Ø±Ù‚Ù… {hadith_id}.\nØ§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù…ØªÙˆÙØ±Ø©: 1-{len(self.db)}"
            )
            return
        status = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...")
        await self._display_hadith(user_id, hadith, status)

    async def _handle_general_query(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int) -> None:
        text_input = update.message.text or ""
        if not text_input.strip():
            await update.message.reply_text("âŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ ÙÙ‡Ù… Ø±Ø³Ø§Ù„ØªÙƒ.")
            return
        status = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙÙƒÙŠØ±...")
        # Ø¥Ø±Ø³Ø§Ù„ Ø³ÙŠØ§Ù‚ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ù…Ù†Ø§Ù‚ÙØ´ Ø¥Ù„Ù‰ AI
        active_hid    = self.ai.memory.get_active_hadith(user_id)
        active_hadith = self.db.get_by_id(active_hid) if active_hid else None
        ai_response   = await self.ai.generate_response(user_id, text_input, active_hadith=active_hadith)
        formatted     = self.fmt.format_response(ai_response)
        if len(formatted) > 4096:
            await status.edit_text(formatted[:4093] + "...", parse_mode=ParseMode.MARKDOWN)
            await update.message.reply_text(formatted[4093:], parse_mode=ParseMode.MARKDOWN)
        else:
            await status.edit_text(formatted, parse_mode=ParseMode.MARKDOWN)
        self.user_data.increment_interaction(user_id)
        await self._send_support_if_due(user_id, context.bot)

        # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø§Ù„Ø¯ÙˆØ±ÙŠ ÙƒÙ„ MONETAG_INTERVAL ØªÙØ§Ø¹Ù„
        interaction_count = self.user_data._load(user_id).get("interaction_count", 0)
        if MonetagSystem.should_show_interval_ad(user_id, interaction_count):
            await asyncio.sleep(2)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=user_id,
                context_label="ğŸ’¡ *Ù‡Ù„ ØªØ¹Ù„Ù…ØŸ*",
            )

    def _build_plan_text(self, user_id: int, plan: List[int]) -> str:
        read      = set(self.user_data.get_read_hadiths(user_id))
        completed = sum(1 for h in plan if h in read)
        remaining = len(plan) - completed
        pct       = round((completed / len(plan)) * 100, 1) if plan else 0
        text = (
            "ğŸ¯ *Ø®Ø·ØªÙƒ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©*\n"
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n\n"
            f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {completed}/{len(plan)} Ø£Ø­Ø§Ø¯ÙŠØ«\n"
            f"ğŸ“ˆ Ø§Ù„Ù†Ø³Ø¨Ø©: {pct}%\n"
            f"ğŸ“š Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {remaining} Ø­Ø¯ÙŠØ«\n\n"
        )
        if remaining > 0:
            nexts = [h for h in plan if h not in read][:3]
            text += "*ğŸ“– Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„ØªØ§Ù„ÙŠØ©:*\n"
            for hid in nexts:
                h = self.db.get_by_id(hid)
                if h:
                    text += f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {hid}: {h['title']}\n"
        else:
            text += "ğŸ‰ *Ù…Ø¨Ø±ÙˆÙƒ! Ø£ÙƒÙ…Ù„Øª Ø®Ø·ØªÙƒ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©!*"
        return text

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            await context.bot.set_my_commands([
                BotCommand("start",     "ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"),
                BotCommand("list",      "ğŸ“š ÙÙ‡Ø±Ø³ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«"),
                BotCommand("random",    "ğŸŒ€ Ø­Ø¯ÙŠØ« Ø¹Ø´ÙˆØ§Ø¦ÙŠ"),
                BotCommand("daily",     "ğŸ“… Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…"),
                BotCommand("topics",    "ğŸ·ï¸ ØªØµÙØ­ Ø¨Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª"),
                BotCommand("search",    "ğŸ” Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«"),
                BotCommand("quiz",      "ğŸ“ Ø§Ø®ØªØ¨Ø± Ù†ÙØ³Ùƒ"),
                BotCommand("flashcard", "ğŸƒ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸"),
                BotCommand("selftest",  "ğŸ¤” Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù"),
                BotCommand("plan",      "ğŸ¯ Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ©"),
                BotCommand("stats",     "ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ"),
                BotCommand("badges",    "ğŸ… Ø´Ø§Ø±Ø§ØªÙŠ"),
                BotCommand("favorites", "â­ Ø§Ù„Ù…ÙØ¶Ù„Ø©"),
                BotCommand("review",    "ğŸ“‹ ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©"),
                BotCommand("reminder",  "â° Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ"),
                BotCommand("feedback",  "ğŸ’¬ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"),
                BotCommand("cancel",    "ğŸš« Ø¥Ù„ØºØ§Ø¡"),
                BotCommand("help",      "â“ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"),
            ])
            await update.message.reply_text(
                self._WELCOME_TEXT,
                reply_markup=self._main_keyboard(),
                parse_mode=ParseMode.MARKDOWN,
            )
            # ğŸ”” Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø´Ø±Ù Ø¹Ù†Ø¯ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
            user_id = update.effective_user.id
            interaction_count = self.user_data._load(user_id).get("interaction_count", 0)
            if interaction_count == 0 and DEVELOPER_TELEGRAM_ID:
                try:
                    user     = update.effective_user
                    all_users = self.user_data.get_all_users()
                    safe_name = MessageFormatter.esc(user.first_name or "Ù…Ø¬Ù‡ÙˆÙ„")
                    uname     = f" (@{user.username})" if user.username else ""
                    await context.bot.send_message(
                        chat_id=int(DEVELOPER_TELEGRAM_ID),
                        text=(
                            "ğŸ†• *Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ Ø§Ù†Ø¶Ù…!*\n"
                            f"ğŸ‘¤ Ø§Ù„Ø§Ø³Ù…: {safe_name}{uname}\n"
                            f"ğŸ†” Ø§Ù„Ù…Ø¹Ø±Ù: `{user_id}`\n"
                            f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¢Ù†: *{len(all_users)}*"
                        ),
                        parse_mode=ParseMode.MARKDOWN,
                    )
                except Exception:
                    pass

            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¹Ù†Ø¯ /start Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù‚Ø¯Ø§Ù…Ù‰ ÙÙ‚Ø·
            if interaction_count > 0:
                await asyncio.sleep(2)
                await MonetagSystem.send_ad(
                    context.bot,
                    chat_id=user_id,
                    context_label="ğŸ  *Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ!*",
                )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ start: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",       callback_data="start"),
             InlineKeyboardButton("â° Ø§Ù„ØªØ°ÙƒÙŠØ±",         callback_data="reminder_menu")],
            [SupportSystem.get_button()],
        ])
        await update.message.reply_text(self._HELP_TEXT, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    async def list_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            if context.args:
                await self._handle_hadith_by_number(update, context.args[0], update.effective_user.id)
                return
            if not self.db:
                await update.message.reply_text("âŒ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©.")
                return
            await update.message.reply_text(
                self.fmt.build_hadith_list(self.db.get_all()),
                parse_mode=ParseMode.MARKDOWN,
            )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ list: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„ÙÙ‡Ø±Ø³.")

    async def random_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            hadith = self.db.get_random()
            if not hadith:
                await update.message.reply_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ« Ù…ØªÙˆÙØ±Ø©.")
                return
            status  = await update.message.reply_text("ğŸŒ€ Ø¬Ø§Ø±ÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ÙŠØ«...")
            user_id = update.effective_user.id
            await self._display_hadith(user_id, hadith, status)
            self.user_data.increment_interaction(user_id)
            await self._send_support_if_due(user_id, context.bot)
            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ
            await asyncio.sleep(1)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=user_id,
                context_label="ğŸŒ€ *Ø§Ø³ØªÙ…ØªØ¹ Ø¨Ø§Ù„Ø­Ø¯ÙŠØ«!*",
            )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ random: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def search_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            user_id = update.effective_user.id
            if not context.args:
                await update.message.reply_text(
                    "ğŸ” *Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«*\n"
                    "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n\n"
                    "ğŸ“ *Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:*\n"
                    "`/search [ÙƒÙ„Ù…Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±]`\n\n"
                    "ğŸ’¡ *Ø£Ù…Ø«Ù„Ø©:*\n"
                    "`/search Ø§Ù„Ù†ÙŠØ©`\n"
                    "`/search Ø§Ù„Ø¥ÙŠÙ…Ø§Ù† ÙˆØ§Ù„Ø£Ø¹Ù…Ø§Ù„`\n"
                    "`/search Ø·Ù‡ÙˆØ± Ø§Ù„ØµÙ„Ø§Ø©`",
                    parse_mode=ParseMode.MARKDOWN,
                )
                return

            keyword = " ".join(context.args)

            # Ø±Ø³Ø§Ù„Ø© Ø§Ù†ØªØ¸Ø§Ø±
            status = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...")

            results = self.db.search(keyword)
            text    = self.fmt.build_search_results(results, keyword)

            # Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø£ÙˆÙ„Ù‰ (Ø£Ø³Ø±Ø¹ ÙˆØµÙˆÙ„)
            if results:
                buttons = []
                for h in results[:5]:
                    buttons.append([InlineKeyboardButton(
                        f"ğŸ“– {h['id']}. {h['title'][:35]}{'...' if len(h['title']) > 35 else ''}",
                        callback_data=f"hadith_{h['id']}"
                    )])
                keyboard = InlineKeyboardMarkup(buttons)
                await status.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=keyboard)
            else:
                await status.edit_text(text, parse_mode=ParseMode.MARKDOWN)

            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
            await asyncio.sleep(1)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=user_id,
                context_label="ğŸ” *ÙˆØ¬Ø¯Øª Ù…Ø§ ØªØ¨Ø­Ø« Ø¹Ù†Ù‡!*",
            )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ search: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«.")

    async def topics_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """[Ø¬Ø¯ÙŠØ¯] ØªØµÙØ­ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹"""
        try:
            if context.args:
                # Ø¹Ø±Ø¶ ØªØµÙ†ÙŠÙ Ù…Ø­Ø¯Ø¯
                category = " ".join(context.args)
                hadiths  = self.db.get_by_category(category)
                if not hadiths:
                    await update.message.reply_text(f"âŒ Ù„Ù… Ø£Ø¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ« ÙÙŠ ØªØµÙ†ÙŠÙ: {category}")
                    return
                lines = [f"ğŸ·ï¸ *{category}*\n"]
                for h in hadiths:
                    badge = " âœ¨" if h.get("hadith_type") == "qudsi" else ""
                    lines.append(f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {h['id']}: {h['title']}{badge}")
                lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡")
                await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
            else:
                cats     = self.db.get_categories()
                text, kb = self.fmt.build_categories_menu(cats)
                await update.message.reply_text(text, reply_markup=kb, parse_mode=ParseMode.MARKDOWN)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ topics: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            user_id = update.effective_user.id
            stats   = self.user_data.get_statistics(user_id, len(self.db))
            text    = self.fmt.build_statistics(stats) + SupportSystem.get_stats_footer()
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ… Ø´Ø§Ø±Ø§ØªÙŠ",    callback_data="badges"),
                 InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="start")],
                [SupportSystem.get_button()],
            ])
            await update.message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            await asyncio.sleep(1)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=user_id,
                context_label="ğŸ“Š *Ø±Ø§Ø¦Ø¹! Ø§Ø³ØªÙ…Ø± ÙÙŠ ØªÙ‚Ø¯Ù…Ùƒ*",
            )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ stats: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª.")

    async def badges_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """[Ø¬Ø¯ÙŠØ¯] Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª"""
        try:
            user_id = update.effective_user.id
            earned  = set(self.user_data.get_earned_badges(user_id))
            stats   = self.user_data.get_statistics(user_id, len(self.db))

            lines = ["ğŸ… *Ø´Ø§Ø±Ø§ØªÙƒ ÙˆØ¥Ù†Ø¬Ø§Ø²Ø§ØªÙƒ*\n", "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n"]
            for badge_id, badge in BADGES.items():
                if badge_id in earned:
                    lines.append(f"âœ… {badge['emoji']} *{badge['name']}* â€” {badge['desc']}")
                else:
                    lines.append(f"ğŸ”’ â–‘ *{badge['name']}* â€” {badge['desc']}")

            lines.append(f"\nğŸ“Š *Ù…ÙƒØªØ³Ø¨:* {len(earned)}/{len(BADGES)} Ø´Ø§Ø±Ø©")
            lines.append(f"ğŸ”¥ *Ø§Ù„Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:* {stats['streak']} ÙŠÙˆÙ…")

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ", callback_data="stats"),
                 InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start")],
            ])
            await update.message.reply_text("\n".join(lines), reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø§Ø±Ø§Øª
            await asyncio.sleep(1)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=user_id,
                context_label="ğŸ… *Ø£Ø­Ø³Ù†Øª! Ø¥Ù„ÙŠÙƒ Ø´ÙŠØ¡ Ù‚Ø¯ ÙŠÙ‡Ù…Ùƒ*",
            )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ badges: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def favorites_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            user_id   = update.effective_user.id
            favorites = self.user_data.get_favorites(user_id)
            if not favorites:
                await update.message.reply_text(
                    "â­ *Ø§Ù„Ù…ÙØ¶Ù„Ø© ÙØ§Ø±ØºØ©*\n\n"
                    "Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ø¶Ø§ÙØ© Ø£ÙŠ Ø­Ø¯ÙŠØ« Ù„Ù„Ù…ÙØ¶Ù„Ø© Ø¨Ø¹Ø¯.\n"
                    "Ø¹Ù†Ø¯ Ø¹Ø±Ø¶ Ø£ÙŠ Ø­Ø¯ÙŠØ«ØŒ Ø§Ø¶ØºØ· â˜† Ù„Ø¥Ø¶Ø§ÙØªÙ‡.",
                    parse_mode=ParseMode.MARKDOWN,
                )
                return
            lines = ["â­ *Ø£Ø­Ø§Ø¯ÙŠØ«Ùƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©:*\n"]
            for hid in favorites:
                h = self.db.get_by_id(hid)
                if h:
                    lines.append(f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {hid}: {h['title']}")
            lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡")
            await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)
            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø¹Ø±Ø¶ Ø§Ù„Ù…ÙØ¶Ù„Ø©
            await asyncio.sleep(1)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=update.effective_user.id,
                context_label="â­ *Ø£Ø­Ø§Ø¯ÙŠØ«Ùƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©!*",
            )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ favorites: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def review_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """[Ø¬Ø¯ÙŠØ¯] Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©"""
        try:
            user_id   = update.effective_user.id
            needs_rev = self.user_data.get_needs_review(user_id)
            if not needs_rev:
                await update.message.reply_text(
                    "ğŸ“‹ *Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ« ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©*\n\n"
                    "Ø§Ø³ØªØ®Ø¯Ù… /selftest Ù„ØªÙ‚ÙŠÙŠÙ… Ù…Ø¹Ø±ÙØªÙƒ Ø¨Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«.",
                    parse_mode=ParseMode.MARKDOWN,
                )
                return
            lines = [f"ğŸ“‹ *Ø£Ø­Ø§Ø¯ÙŠØ« ØªØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø© ({len(needs_rev)}):*\n"]
            for hid in needs_rev:
                h = self.db.get_by_id(hid)
                if h:
                    lines.append(f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {hid}: {h['title']}")
            lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡ ÙˆÙ…Ø±Ø§Ø¬Ø¹ØªÙ‡")
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸƒ Ø§Ø¨Ø¯Ø£ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨Ø·Ø§Ù‚Ø§Øª", callback_data="flashcard_review")],
                [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",             callback_data="start")],
            ])
            await update.message.reply_text("\n".join(lines), reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ review: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def daily_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            user_id = update.effective_user.id
            today   = datetime.now().date().isoformat()
            if self.user_data.get_last_daily(user_id) == today:
                await update.message.reply_text(
                    "ğŸ“… Ù„Ù‚Ø¯ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… Ø¨Ø§Ù„ÙØ¹Ù„!\nØ¹Ø¯ ØºØ¯Ø§Ù‹ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø¯ÙŠØ« Ø¬Ø¯ÙŠØ¯. ğŸŒŸ"
                )
                return
            unread    = self.user_data.get_unread_hadiths(user_id, len(self.db))
            hadith_id = random.choice(unread) if unread else random.randint(1, len(self.db))
            hadith    = self.db.get_by_id(hadith_id)
            if hadith:
                status = await update.message.reply_text("ğŸ“… Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…...")
                self.user_data.update_last_daily(user_id)
                remaining = len(unread) - 1 if unread else 0
                prefix    = f"ğŸ“… *Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…*\nğŸ“š ØªØ¨Ù‚Ù‰ Ù„Ùƒ {remaining} Ø­Ø¯ÙŠØ«Ø§Ù‹ Ù„Ù„Ø¥ØªÙ…Ø§Ù…!\n\n"
                await self._display_hadith(user_id, hadith, status, prefix=prefix)
                self.user_data.increment_interaction(user_id)
                await self._send_support_if_due(user_id, context.bot)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ daily: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def quiz_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            user_id = update.effective_user.id
            if QuizSystem.is_active(user_id):
                await update.message.reply_text(
                    "âš ï¸ Ù„Ø¯ÙŠÙƒ Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø´Ø·!\nØ£ÙƒÙ…Ù„Ù‡ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… /cancel_quiz Ù„Ø¥Ù„ØºØ§Ø¦Ù‡."
                )
                return
            questions = QuizSystem.generate_quiz(self.db, question_count=5)
            if not questions:
                await update.message.reply_text("âŒ ØªØ¹Ø°Ù‘Ø± ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return
            QuizSystem.start(user_id, questions)
            await self._show_quiz_question(update.message, user_id)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ quiz: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.")

    async def cancel_quiz_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if not QuizSystem.is_active(user_id):
            await update.message.reply_text("âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø´Ø·.")
            return
        QuizSystem.cancel(user_id)
        await update.message.reply_text(
            "âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… `/quiz`",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def flashcard_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """[Ø¬Ø¯ÙŠØ¯] Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸"""
        try:
            user_id = update.effective_user.id
            if FlashcardSystem.is_active(user_id):
                await update.message.reply_text("âš ï¸ Ù„Ø¯ÙŠÙƒ Ø¬Ù„Ø³Ø© Ø¨Ø·Ø§Ù‚Ø§Øª Ù†Ø´Ø·Ø©.")
                return
            all_ids = [h["id"] for h in self.db.get_all()]
            FlashcardSystem.start(user_id, all_ids)
            await self._show_flashcard(update.message, user_id)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ flashcard: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def selftest_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """[Ø¬Ø¯ÙŠØ¯] Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù"""
        try:
            user_id   = update.effective_user.id
            all_ids   = [h["id"] for h in self.db.get_all()]
            random.shuffle(all_ids)
            hadith_id = all_ids[0]
            hadith    = self.db.get_by_id(hadith_id)
            if not hadith:
                await update.message.reply_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ«.")
                return
            await self._show_selftest(update.message, hadith)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ selftest: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def plan_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            user_id  = update.effective_user.id
            cur_plan = self.user_data.get_study_plan(user_id)
            if not cur_plan:
                await update.message.reply_text(
                    "ğŸ¯ *Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ©*\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©:",
                    reply_markup=self._plan_choice_keyboard(),
                    parse_mode=ParseMode.MARKDOWN,
                )
            else:
                await update.message.reply_text(
                    self._build_plan_text(user_id, cur_plan),
                    parse_mode=ParseMode.MARKDOWN,
                )
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ plan: {exc}")
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£.")

    async def note_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args or len(context.args) < 2:
            await update.message.reply_text(
                "ğŸ“ *ÙƒÙŠÙÙŠØ© Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø©:*\n"
                "Ø§Ø³ØªØ®Ø¯Ù…: `/note [Ø±Ù‚Ù…_Ø§Ù„Ø­Ø¯ÙŠØ«] [Ù…Ù„Ø§Ø­Ø¸ØªÙƒ]`\n\n"
                "*Ù…Ø«Ø§Ù„:*\n`/note 1 Ø­Ø¯ÙŠØ« Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ Ø¹Ù† Ø§Ù„Ù†ÙŠØ©`",
                parse_mode=ParseMode.MARKDOWN,
            )
            return
        try:
            hadith_id = int(context.args[0])
            note_text = " ".join(context.args[1:])
            user_id   = update.effective_user.id
            if self.user_data.add_note(user_id, hadith_id, note_text):
                await update.message.reply_text(f"âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ÙŠØ« Ø±Ù‚Ù… {hadith_id}")
            else:
                await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©")
        except ValueError:
            await update.message.reply_text("âŒ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± ØµØ­ÙŠØ­")

    async def feedback_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        FeedbackSystem.start(user_id)
        await update.message.reply_text(
            "ğŸ’¬ *ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§*\n\nÙ†Ø³Ø¹Ø¯ Ø¨Ø³Ù…Ø§Ø¹ Ø±Ø£ÙŠÙƒ! ğŸŒŸ\n\n"
            "â€¢ ğŸ› ØªÙ‚Ø±ÙŠØ± Ø¹Ù† Ù…Ø´ÙƒÙ„Ø©\n"
            "â€¢ ğŸ’¡ Ø§Ù‚ØªØ±Ø§Ø­ Ù…ÙŠØ²Ø©\n"
            "â€¢ ğŸ“ Ù…Ù„Ø§Ø­Ø¸Ø© Ø£Ùˆ Ø±Ø£ÙŠ\n\n"
            "*ğŸ“¨ Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø§Ù„Ø¢Ù†*\nØ£Ùˆ `/cancel` Ù„Ù„Ø¥Ù„ØºØ§Ø¡",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def reminder_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id  = update.effective_user.id
        settings = self.user_data.get_reminder_settings(user_id)

        if not context.args:
            status   = "ğŸŸ¢ Ù…ÙØ¹Ù‘Ù„" if settings["enabled"] else "ğŸ”´ Ù…Ø¹Ø·Ù‘Ù„"
            evening  = settings.get("time_evening") or "ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„"
            text = (
                "â° *Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ*\n\n"
                f"*Ø§Ù„Ø­Ø§Ù„Ø©:* {status}\n"
                f"*Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ØµØ¨Ø§Ø­ÙŠ:* {settings['time']}\n"
                f"*Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø¦ÙŠ:* {evening}\n"
                f"*Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©:* {settings['timezone']}\n\n"
                "*ğŸ“ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:*\n"
                "`/reminder on 08:00` â€” ØªÙØ¹ÙŠÙ„ ØµØ¨Ø§Ø­ÙŠ\n"
                "`/reminder evening 22:00` â€” ØªÙØ¹ÙŠÙ„ Ù…Ø³Ø§Ø¦ÙŠ\n"
                "`/reminder evening off` â€” Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¦ÙŠ\n"
                "`/reminder set 20:00` â€” ØªØºÙŠÙŠØ± Ø§Ù„ÙˆÙ‚Øª\n"
                "`/reminder off` â€” ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ÙƒÙ„"
            )
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸŸ¢ ØªÙØ¹ÙŠÙ„",  callback_data="reminder_on"),
                 InlineKeyboardButton("ğŸ”´ ØªØ¹Ø·ÙŠÙ„", callback_data="reminder_off")],
                [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="start")],
            ])
            await update.message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
            return

        cmd = context.args[0].lower()
        if cmd == "on":
            time_str = context.args[1] if len(context.args) > 1 else DEFAULT_REMINDER_TIME
            if not ReminderSystem.parse_time(time_str):
                await update.message.reply_text("âŒ ØµÙŠØºØ© Ø§Ù„ÙˆÙ‚Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©! Ø§Ø³ØªØ®Ø¯Ù…: `HH:MM`", parse_mode=ParseMode.MARKDOWN)
                return
            self.user_data.enable_reminder(user_id, time_str)
            await update.message.reply_text(
                f"âœ… *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ØµØ¨Ø§Ø­ÙŠ!*\n\nâ° Ø§Ù„Ø³Ø§Ø¹Ø© {time_str} ÙŠÙˆÙ…ÙŠØ§Ù‹",
                parse_mode=ParseMode.MARKDOWN,
            )
        elif cmd == "evening":
            if len(context.args) < 2:
                await update.message.reply_text("âš ï¸ Ø­Ø¯Ù‘Ø¯ Ø§Ù„ÙˆÙ‚Øª! Ù…Ø«Ø§Ù„: `/reminder evening 22:00`", parse_mode=ParseMode.MARKDOWN)
                return
            if context.args[1].lower() == "off":
                self.user_data.disable_evening_reminder(user_id)
                await update.message.reply_text("ğŸ”´ *ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø¦ÙŠ*", parse_mode=ParseMode.MARKDOWN)
            else:
                time_str = context.args[1]
                if not ReminderSystem.parse_time(time_str):
                    await update.message.reply_text("âŒ ØµÙŠØºØ© Ø§Ù„ÙˆÙ‚Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©!", parse_mode=ParseMode.MARKDOWN)
                    return
                self.user_data.enable_evening_reminder(user_id, time_str)
                await update.message.reply_text(
                    f"âœ… *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø¦ÙŠ!*\n\nğŸŒ™ Ø§Ù„Ø³Ø§Ø¹Ø© {time_str} ÙŠÙˆÙ…ÙŠØ§Ù‹",
                    parse_mode=ParseMode.MARKDOWN,
                )
        elif cmd == "off":
            self.user_data.disable_reminder(user_id)
            await update.message.reply_text(
                "ğŸ”´ *ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ*\n\nÙŠÙ…ÙƒÙ†Ùƒ ØªÙØ¹ÙŠÙ„Ù‡ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø¨Ù€ `/reminder on`",
                parse_mode=ParseMode.MARKDOWN,
            )
        elif cmd == "set":
            if len(context.args) < 2 or not ReminderSystem.parse_time(context.args[1]):
                await update.message.reply_text("âš ï¸ Ù…Ø«Ø§Ù„: `/reminder set 09:00`", parse_mode=ParseMode.MARKDOWN)
                return
            self.user_data.enable_reminder(user_id, context.args[1])
            await update.message.reply_text(f"âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø§Ù„ØªØ°ÙƒÙŠØ± Ø¥Ù„Ù‰:* {context.args[1]}", parse_mode=ParseMode.MARKDOWN)
        else:
            await update.message.reply_text("âŒ Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ! Ø§Ø³ØªØ®Ø¯Ù… `/reminder` Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©", parse_mode=ParseMode.MARKDOWN)


    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø´Ø±Ù â€” Ù…Ø®ÙÙŠØ© Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¹Ø§Ø¯ÙŠÙŠÙ†
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    @admin_only
    async def admin_help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        text = (
            "ğŸ” *Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø´Ø±Ù â€” Ù†Ø¨Ø±Ø§Ø³*\n"
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n\n"
            "ğŸ“Š `/admin_stats` â€” Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª\n"
            "ğŸ† `/admin_top` â€” Ø£Ù†Ø´Ø· 10 Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†\n"
            "ğŸ˜´ `/admin_inactive` â€” ØºÙŠØ± Ù†Ø´Ø·ÙŠÙ† â‰¥7 Ø£ÙŠØ§Ù…\n\n"
            "ğŸ“¢ `/admin_broadcast [Ø±Ø³Ø§Ù„Ø©]` â€” Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ©\n"
            "ğŸ“£ `/admin_announce [Ø±Ø³Ø§Ù„Ø©]` â€” Ø¥Ø¹Ù„Ø§Ù† Ù…Ù…ÙŠØ²\n\n"
            "ğŸš« `/admin_ban [id]` â€” Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n"
            "âœ… `/admin_unban [id]` â€” Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø±\n"
            "ğŸ” `/admin_user [id]` â€” Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³ØªØ®Ø¯Ù…\n"
            "ğŸ“‹ `/admin_export` â€” ØªØµØ¯ÙŠØ± CSV\n\n"
            "ğŸ”§ `/admin_maintenance on/off` â€” ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©\n"
            "â“ `/admin_help` â€” Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©\n"
        )
        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

    @admin_only
    async def admin_stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        users = self.user_data.get_all_users()
        total = len(users)
        if total == 0:
            await update.message.reply_text("ğŸ“Š Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø¨Ø¹Ø¯.")
            return

        active_today = active_week = banned_count = 0
        total_reads  = total_inter = reminder_on  = completed_40 = 0
        from datetime import timezone as dt_tz
        now = datetime.now(dt_tz.utc)

        for uid, data in users:
            reads = len(data.get("read_hadiths", []))
            total_reads += reads
            total_inter += data.get("interaction_count", 0)
            if data.get("banned"):           banned_count += 1
            if data.get("reminder_enabled"): reminder_on  += 1
            if reads >= 42:                  completed_40 += 1
            last = data.get("streak_last_date")
            if last:
                try:
                    last_dt = datetime.fromisoformat(last)
                    if last_dt.tzinfo is None:
                        last_dt = last_dt.replace(tzinfo=dt_tz.utc)
                    diff = (now.date() - last_dt.date()).days
                    if diff == 0: active_today += 1
                    if diff <= 7: active_week  += 1
                except Exception:
                    pass

        avg = round(total_reads / total, 1) if total else 0
        text = (
            "ğŸ“Š *Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª â€” Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø´Ø±Ù*\n"
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n\n"
            f"ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: *{total}*\n"
            f"ğŸŸ¢ Ù†Ø´Ø·ÙˆÙ† Ø§Ù„ÙŠÙˆÙ…: *{active_today}*\n"
            f"ğŸ“… Ù†Ø´Ø·ÙˆÙ† Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹: *{active_week}*\n"
            f"â›” Ù…Ø­Ø¸ÙˆØ±ÙˆÙ†: *{banned_count}*\n\n"
            f"ğŸ“– Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø§Øª: *{total_reads}*\n"
            f"ğŸ’¬ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª: *{total_inter}*\n"
            f"ğŸ“ Ø£ØªÙ…Ù‘ÙˆØ§ Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ†: *{completed_40}*\n"
            f"â° Ù…ÙØ¹Ù‘Ù„Ùˆ Ø§Ù„ØªØ°ÙƒÙŠØ±: *{reminder_on}*\n\n"
            f"ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©/Ù…Ø³ØªØ®Ø¯Ù…: *{avg}*\n"
        )
        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

    @admin_only
    async def admin_broadcast_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args:
            await update.message.reply_text(
                "ğŸ“¢ *Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠØ©*\n\n"
                "Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n`/admin_broadcast Ø±Ø³Ø§Ù„ØªÙƒ Ù‡Ù†Ø§`\n\n"
                "âš ï¸ Ø³ØªÙØ±Ø³Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.",
                parse_mode=ParseMode.MARKDOWN,
            )
            return

        message_text = " ".join(context.args)
        users  = self.user_data.get_all_users()
        total  = len(users)
        status = await update.message.reply_text(f"ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù€ {total} Ù…Ø³ØªØ®Ø¯Ù…...")

        sent = failed = blocked = 0
        for uid, data in users:
            if data.get("banned"):
                continue
            try:
                await context.bot.send_message(
                    chat_id=uid,
                    text=(
                        "ğŸ“¢ *Ø±Ø³Ø§Ù„Ø© Ù…Ù† ÙØ±ÙŠÙ‚ Ù†Ø¨Ø±Ø§Ø³*\n"
                        "Ù€Ù€Ù€Ù€Ù€\n\n"
                        f"{MessageFormatter.esc(message_text)}"
                    ),
                    parse_mode=ParseMode.MARKDOWN,
                )
                sent += 1
                await asyncio.sleep(0.05)
            except Exception as e:
                err = str(e).lower()
                if "blocked" in err or "forbidden" in err:
                    blocked += 1
                else:
                    failed += 1

        await status.edit_text(
            f"âœ… *Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„*\n\n"
            f"ğŸ“¨ Ø£ÙØ±Ø³Ù„Øª: {sent}\n"
            f"ğŸš« Ø­Ø¬Ø¨ÙˆØ§ Ø§Ù„Ø¨ÙˆØª: {blocked}\n"
            f"âŒ ÙØ´Ù„: {failed}\n"
            f"ğŸ“Š Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total}",
            parse_mode=ParseMode.MARKDOWN,
        )

    @admin_only
    async def admin_ban_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args or not context.args[0].isdigit():
            await update.message.reply_text(
                "ğŸš« *Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…*\n\nØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n`/admin_ban 123456789`",
                parse_mode=ParseMode.MARKDOWN,
            )
            return
        uid = int(context.args[0])
        if is_admin(uid):
            await update.message.reply_text("â›” Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¸Ø± Ø§Ù„Ù…Ø´Ø±Ù.")
            return
        self.user_data.ban_user(uid)
        await update.message.reply_text(
            f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{uid}` Ø¨Ù†Ø¬Ø§Ø­.",
            parse_mode=ParseMode.MARKDOWN,
        )
        try:
            await context.bot.send_message(chat_id=uid, text="â›” ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")
        except Exception:
            pass

    @admin_only
    async def admin_unban_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args or not context.args[0].isdigit():
            await update.message.reply_text(
                "âœ… *Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø±*\n\nØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n`/admin_unban 123456789`",
                parse_mode=ParseMode.MARKDOWN,
            )
            return
        uid = int(context.args[0])
        self.user_data.unban_user(uid)
        await update.message.reply_text(
            f"âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø± Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{uid}`.",
            parse_mode=ParseMode.MARKDOWN,
        )
        try:
            await context.bot.send_message(
                chat_id=uid,
                text="âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø± Ø¹Ù†ÙƒØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ù…Ø¬Ø¯Ø¯Ø§Ù‹.",
            )
        except Exception:
            pass

    @admin_only
    async def admin_user_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args or not context.args[0].isdigit():
            await update.message.reply_text(
                "ğŸ” *Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³ØªØ®Ø¯Ù…*\n\nØ§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n`/admin_user 123456789`",
                parse_mode=ParseMode.MARKDOWN,
            )
            return
        uid    = int(context.args[0])
        data   = self.user_data._load(uid)
        reads  = len(data.get("read_hadiths", []))
        inter  = data.get("interaction_count", 0)
        streak = data.get("streak_count", 0)
        badges = data.get("badges", [])
        banned = data.get("banned", False)
        rem    = data.get("reminder_enabled", False)
        tz     = data.get("reminder_timezone", "â€”")
        badges_str = " ".join(BADGES[b]["emoji"] for b in badges if b in BADGES) or "Ù„Ø§ ØªÙˆØ¬Ø¯"
        text = (
            f"ğŸ” *Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…* `{uid}`\n"
            "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n\n"
            f"ğŸ“– Ø£Ø­Ø§Ø¯ÙŠØ« Ù…Ù‚Ø±ÙˆØ¡Ø©: {reads}/42\n"
            f"ğŸ’¬ ØªÙØ§Ø¹Ù„Ø§Øª: {inter}\n"
            f"ğŸ”¥ Ø§Ù„Ø³Ù„Ø³Ù„Ø©: {streak} ÙŠÙˆÙ…\n"
            f"ğŸ… Ø´Ø§Ø±Ø§Øª: {badges_str}\n"
            f"â° ØªØ°ÙƒÙŠØ±: {'âœ…' if rem else 'âŒ'} ({tz})\n"
            f"â›” Ù…Ø­Ø¸ÙˆØ±: {'Ù†Ø¹Ù…' if banned else 'Ù„Ø§'}\n"
        )
        label = "âœ… Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø±" if banned else "ğŸš« Ø­Ø¸Ø±"
        cb    = f"admin_unban_{uid}" if banned else f"admin_ban_{uid}"
        keyboard = InlineKeyboardMarkup([[InlineKeyboardButton(label, callback_data=cb)]])
        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=keyboard)

    @admin_only
    async def admin_export_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        import csv, io
        users = self.user_data.get_all_users()
        if not users:
            await update.message.reply_text("ğŸ“‹ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±.")
            return
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(["user_id", "read_hadiths", "interaction_count",
                         "streak_count", "badges", "reminder_enabled", "banned"])
        for uid, data in users:
            writer.writerow([
                uid,
                len(data.get("read_hadiths", [])),
                data.get("interaction_count", 0),
                data.get("streak_count", 0),
                len(data.get("badges", [])),
                data.get("reminder_enabled", False),
                data.get("banned", False),
            ])
        output.seek(0)
        csv_bytes = output.getvalue().encode("utf-8-sig")
        await update.message.reply_document(
            document=csv_bytes,
            filename="nibras_users.csv",
            caption=f"ğŸ“‹ *Ø¨ÙŠØ§Ù†Ø§Øª {len(users)} Ù…Ø³ØªØ®Ø¯Ù…*",
            parse_mode=ParseMode.MARKDOWN,
        )


    @admin_only
    async def admin_top_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """ğŸ“ˆ /admin_top â€” Ø£ÙƒØ«Ø± 10 Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø§Ø·Ø§Ù‹"""
        users = self.user_data.get_all_users()
        if not users:
            await update.message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø¨Ø¹Ø¯.")
            return
        # ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø§Øª Ø«Ù… Ø§Ù„ØªÙØ§Ø¹Ù„Ø§Øª
        ranked = sorted(
            users,
            key=lambda x: (
                len(x[1].get("read_hadiths", [])),
                x[1].get("interaction_count", 0)
            ),
            reverse=True
        )[:10]

        lines = ["ğŸ† *Ø£ÙƒØ«Ø± 10 Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø§Ø·Ø§Ù‹*\n" "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n"]
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"] + ["ğŸ…"] * 7
        for i, (uid, data) in enumerate(ranked):
            reads  = len(data.get("read_hadiths", []))
            inter  = data.get("interaction_count", 0)
            streak = data.get("streak_count", 0)
            lines.append(
                f"{medals[i]} `{uid}`\n"
                f"   ğŸ“– {reads}/42 Ù‚Ø±Ø§Ø¡Ø©  â€¢  ğŸ’¬ {inter} ØªÙØ§Ø¹Ù„  â€¢  ğŸ”¥ {streak}Ø¯"
            )
        await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)

    @admin_only
    async def admin_inactive_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """ğŸ˜´ /admin_inactive â€” Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† ØºÙŠØ± Ù†Ø´Ø·ÙŠÙ† Ù…Ù†Ø° Ø£Ø³Ø¨ÙˆØ¹"""
        from datetime import timezone as dt_tz
        now   = datetime.now(dt_tz.utc)
        users = self.user_data.get_all_users()
        inactive = []
        for uid, data in users:
            if data.get("banned"):
                continue
            last = data.get("streak_last_date")
            if not last:
                # Ù„Ù… ÙŠØªÙØ§Ø¹Ù„ Ø£Ø¨Ø¯Ø§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
                inactive.append((uid, data, 999))
                continue
            try:
                last_dt = datetime.fromisoformat(last)
                if last_dt.tzinfo is None:
                    last_dt = last_dt.replace(tzinfo=dt_tz.utc)
                days = (now.date() - last_dt.date()).days
                if days >= 7:
                    inactive.append((uid, data, days))
            except Exception:
                pass

        inactive.sort(key=lambda x: x[2], reverse=True)
        total = len(inactive)

        if total == 0:
            await update.message.reply_text("âœ… Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† ØºÙŠØ± Ù†Ø´Ø·ÙŠÙ† Ù…Ù†Ø° Ø£Ø³Ø¨ÙˆØ¹!")
            return

        lines = [
            f"ğŸ˜´ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† ØºÙŠØ± Ø§Ù„Ù†Ø´Ø·ÙŠÙ† (â‰¥7 Ø£ÙŠØ§Ù…)*\n"
            f"Ø§Ù„Ø¹Ø¯Ø¯: {total} Ù…Ø³ØªØ®Ø¯Ù…\nÙ€Ù€Ù€Ù€Ù€Ù€Ù€\n"
        ]
        for uid, data, days in inactive[:15]:
            reads = len(data.get("read_hadiths", []))
            day_str = "Ù„Ù… ÙŠØªÙØ§Ø¹Ù„ Ø£Ø¨Ø¯Ø§Ù‹" if days == 999 else f"Ù…Ù†Ø° {days} ÙŠÙˆÙ…"
            lines.append(f"â€¢ `{uid}` â€” {day_str} â€” {reads}/42 Ù‚Ø±Ø§Ø¡Ø©")

        if total > 15:
            lines.append(f"\n_...Ùˆ {total-15} Ø¢Ø®Ø±ÙˆÙ†_")

        lines.append(
            f"\nğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… `/admin_broadcast` Ù„Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ´Ø¬ÙŠØ¹ÙŠØ© Ù„Ù‡Ù…."
        )
        await update.message.reply_text("\n".join(lines), parse_mode=ParseMode.MARKDOWN)

    @admin_only
    async def admin_announce_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """ğŸ“£ /admin_announce [Ø±Ø³Ø§Ù„Ø©] â€” Ø¥Ø¹Ù„Ø§Ù† Ù…Ù…ÙŠØ² Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø®Ø§Øµ"""
        if not context.args:
            await update.message.reply_text(
                "ğŸ“£ *Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† Ø§Ù„Ù…Ù…ÙŠØ²*\n\n"
                "Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n`/admin_announce Ù†Øµ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†`\n\n"
                "ÙŠÙØ±Ø³Ù„ Ø¨ØªÙ†Ø³ÙŠÙ‚ Ù…Ù…ÙŠØ² ÙŠØ®ØªÙ„Ù Ø¹Ù† broadcast Ø§Ù„Ø¹Ø§Ø¯ÙŠ.",
                parse_mode=ParseMode.MARKDOWN,
            )
            return

        msg_text = " ".join(context.args)
        users    = self.user_data.get_all_users()
        total    = len(users)
        status   = await update.message.reply_text(f"ğŸ“£ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† Ù„Ù€ {total} Ù…Ø³ØªØ®Ø¯Ù…...")

        announce_text = (
            "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
            "â•‘  ğŸ“£ *Ø¥Ø¹Ù„Ø§Ù† Ù†Ø¨Ø±Ø§Ø³*  â•‘\n"
            "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
            f"{MessageFormatter.esc(msg_text)}\n\n"
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "ğŸŒ¿ _ÙØ±ÙŠÙ‚ Ù†Ø¨Ø±Ø§Ø³ â€” Ø§Ù„Ø£Ø±Ø¨Ø¹ÙˆÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©_"
        )

        sent = failed = blocked = 0
        for uid, data in users:
            if data.get("banned"):
                continue
            try:
                await context.bot.send_message(
                    chat_id=uid,
                    text=announce_text,
                    parse_mode=ParseMode.MARKDOWN,
                )
                sent += 1
                await asyncio.sleep(0.05)
            except Exception as e:
                err = str(e).lower()
                if "blocked" in err or "forbidden" in err:
                    blocked += 1
                else:
                    failed += 1

        await status.edit_text(
            f"âœ… *Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†*\n\n"
            f"ğŸ“¨ Ø£ÙØ±Ø³Ù„ Ù„Ù€: {sent}\n"
            f"ğŸš« Ø­Ø¬Ø¨ÙˆØ§ Ø§Ù„Ø¨ÙˆØª: {blocked}\n"
            f"âŒ ÙØ´Ù„: {failed}",
            parse_mode=ParseMode.MARKDOWN,
        )

    @admin_only
    async def admin_maintenance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """ğŸ”§ /admin_maintenance [on/off] [Ø±Ø³Ø§Ù„Ø©] â€” ØªÙØ¹ÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©"""
        global _maintenance_mode, _maintenance_message

        if not context.args:
            status_text = "Ù…ÙØ¹Ù‘Ù„ âœ…" if _maintenance_mode else "Ù…Ø¹Ø·Ù‘Ù„ âŒ"
            await update.message.reply_text(
                f"ğŸ”§ *ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ø­Ø§Ù„ÙŠ:* {status_text}\n\n"
                "Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n"
                "`/admin_maintenance on` â€” ØªÙØ¹ÙŠÙ„\n"
                "`/admin_maintenance off` â€” Ø¥ÙŠÙ‚Ø§Ù\n"
                "`/admin_maintenance on Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ«...` â€” Ù…Ø¹ Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ©",
                parse_mode=ParseMode.MARKDOWN,
            )
            return

        action = context.args[0].lower()
        custom_msg = " ".join(context.args[1:]) if len(context.args) > 1 else ""

        if action == "on":
            _maintenance_mode = True
            if custom_msg:
                _maintenance_message = f"ğŸ”§ {custom_msg}"
            else:
                _maintenance_message = "ğŸ”§ Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹."
            await update.message.reply_text(
                f"ğŸ”§ *ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø© Ù…ÙØ¹ÙÙ‘Ù„*\n\n"
                f"ğŸ“ Ø§Ù„Ø±Ø³Ø§Ù„Ø©: _{MessageFormatter.esc(_maintenance_message)}_\n\n"
                "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø³ÙŠØ­ØµÙ„ÙˆÙ† Ø¹Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø­ØªÙ‰ ØªÙÙˆÙ‚Ù Ø§Ù„ØµÙŠØ§Ù†Ø©.",
                parse_mode=ParseMode.MARKDOWN,
            )
        elif action == "off":
            _maintenance_mode = False
            await update.message.reply_text("âœ… *ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø£ÙÙˆÙ‚Ù* â€” Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ Ø§Ù„Ø¢Ù†.", parse_mode=ParseMode.MARKDOWN)
        else:
            await update.message.reply_text("âš ï¸ Ø§Ø³ØªØ®Ø¯Ù… `on` Ø£Ùˆ `off`.", parse_mode=ParseMode.MARKDOWN)


    async def cancel_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if QuizSystem.is_active(user_id):
            QuizSystem.cancel(user_id)
            await update.message.reply_text("âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.")
            return
        if FlashcardSystem.is_active(user_id):
            FlashcardSystem.cancel(user_id)
            await update.message.reply_text("âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¬Ù„Ø³Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª.")
            return
        if FeedbackSystem.is_active(user_id):
            FeedbackSystem.stop(user_id)
            await update.message.reply_text("âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©.")
            return
        if NoteSystem.is_active(user_id):
            NoteSystem.stop(user_id)
            await update.message.reply_text("âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©.")
            return
        await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„ÙŠØ© Ù†Ø´Ø·Ø© Ù„Ù„Ø¥Ù„ØºØ§Ø¡.")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def message_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            msg     = update.message
            user_id = update.effective_user.id

            # Ø±Ø¯ Ø§Ù„Ù…Ø´Ø±Ù Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† feedback
            if is_admin(user_id) and context.user_data.get("reply_to_user"):
                target_uid = context.user_data.pop("reply_to_user")
                reply_text = msg.text.strip()
                try:
                    await context.bot.send_message(
                        chat_id=target_uid,
                        text=(
                            "ğŸ“© *Ø±Ø¯ Ù…Ù† ÙØ±ÙŠÙ‚ Ù†Ø¨Ø±Ø§Ø³*\n"
                            "Ù€Ù€Ù€Ù€Ù€\n\n"
                            f"{MessageFormatter.esc(reply_text)}"
                        ),
                        parse_mode=ParseMode.MARKDOWN,
                    )
                    await msg.reply_text(f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø¯Ùƒ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… `{target_uid}`.", parse_mode=ParseMode.MARKDOWN)
                except Exception as e:
                    await msg.reply_text(f"âŒ ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {e}")
                return

            # ÙØ­Øµ ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©
            global _maintenance_mode, _maintenance_message
            if _maintenance_mode and not is_admin(user_id):
                await msg.reply_text(_maintenance_message)
                return

            # ÙØ­Øµ Ø§Ù„Ø­Ø¸Ø±
            if self.user_data.is_banned(user_id):
                await msg.reply_text("â›” ØªÙ… Ø­Ø¸Ø±Ùƒ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª.")
                return

            if msg.voice:
                await msg.reply_text("âŒ Ù„Ø§ Ø£Ù‚Ø¨Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØµÙˆØªÙŠØ©.\nÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ø£Ùˆ Ø³Ø¤Ø§Ù„ Ù†ØµÙŠ.")
                return
            if msg.photo or msg.document or msg.video or msg.sticker:
                await msg.reply_text("âŒ Ø£Ù†Ø§ Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ© ÙÙ‚Ø·.")
                return
            if not msg.text:
                return

            text = msg.text.strip()

            if FeedbackSystem.is_active(user_id):
                await self._handle_feedback_message(update, context)
                return
            if NoteSystem.is_active(user_id):
                await self._handle_note_input(update, user_id)
                return
            if QuizSystem.is_active(user_id):
                await msg.reply_text(
                    "ğŸ“ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±.\nÙ„Ø¥Ù„ØºØ§Ø¡: `/cancel_quiz`",
                    parse_mode=ParseMode.MARKDOWN,
                )
                return

            if text.isdigit():
                await self._handle_hadith_by_number(update, text, user_id)
                return

            await self._handle_general_query(update, context, user_id)

        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ message_handler: {exc}", exc_info=True)
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ù„ØªÙƒ.")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        query   = update.callback_query
        await query.answer()
        data    = query.data
        user_id = update.effective_user.id

        try:
            # â”€â”€ Ø§Ù„Ø­Ø¯ÙŠØ« â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if data.startswith("fav_"):
                await self._cb_favorite(query, user_id, int(data.split("_")[1]))

            elif data.startswith("note_"):
                await self._cb_note(query, user_id, int(data.split("_")[1]))

            elif data.startswith("admin_reply_"):
                # Ø±Ø¯ Ø§Ù„Ù…Ø´Ø±Ù Ù…Ø¨Ø§Ø´Ø±Ø© Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† feedback
                if is_admin(user_id):
                    target_uid = int(data.split("_")[2])
                    context.user_data["reply_to_user"] = target_uid
                    await query.message.reply_text(
                        f"â†©ï¸ *Ø§ÙƒØªØ¨ Ø±Ø¯Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…* `{target_uid}`:\n"
                        "_Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø§Ù„Ø¢Ù† ÙˆØ³ØªØµÙ„ Ø¥Ù„ÙŠÙ‡ Ù…Ø¨Ø§Ø´Ø±Ø©._\n"
                        "Ù„Ø¥Ù„ØºØ§Ø¡: /cancel",
                        parse_mode=ParseMode.MARKDOWN,
                    )

            elif data.startswith("admin_ban_"):
                uid = int(data.split("_")[2])
                if is_admin(user_id):
                    self.user_data.ban_user(uid)
                    await query.answer(f"âœ… ØªÙ… Ø­Ø¸Ø± {uid}", show_alert=True)
                    await query.message.edit_reply_markup(reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton("âœ… Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø±", callback_data=f"admin_unban_{uid}")
                    ]]))

            elif data.startswith("admin_unban_"):
                uid = int(data.split("_")[2])
                if is_admin(user_id):
                    self.user_data.unban_user(uid)
                    await query.answer(f"âœ… Ø±ÙÙØ¹ Ø§Ù„Ø­Ø¸Ø± Ø¹Ù† {uid}", show_alert=True)
                    await query.message.edit_reply_markup(reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton("ğŸš« Ø­Ø¸Ø±", callback_data=f"admin_ban_{uid}")
                    ]]))

            elif data.startswith("hadith_"):
                # ÙØªØ­ Ø­Ø¯ÙŠØ« Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
                hid    = int(data.split("_")[1])
                hadith = self.db.get_by_id(hid)
                if hadith:
                    await self._display_hadith(user_id, hadith, query.message)
                else:
                    await query.answer("âŒ Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)

            elif data.startswith("related_"):
                await self._cb_related(query, user_id, int(data.split("_")[1]))

            elif data.startswith("simple_"):
                await self._cb_simple(query, user_id, int(data.split("_")[1]))

            elif data.startswith("compare_"):
                await self._cb_compare(query, user_id, int(data.split("_")[1]))

            elif data.startswith("narrator_"):
                await self._cb_narrator(query, int(data.split("_")[1]))

            elif data.startswith("english_"):
                await self._cb_english(query, int(data.split("_")[1]))

            elif data.startswith("share_"):
                await self._cb_share(query, int(data.split("_")[1]))

            # â”€â”€ Ø§Ø®ØªØ¨Ø§Ø± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data.startswith("quiz_answer_"):
                await self._cb_quiz_answer(query, user_id, int(data.split("_")[2]))

            # â”€â”€ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data == "flashcard_start":
                all_ids = [h["id"] for h in self.db.get_all()]
                FlashcardSystem.start(user_id, all_ids)
                await query.message.edit_text("ğŸƒ Ø¬Ù„Ø³Ø© Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸ Ø¨Ø¯Ø£Øª...")
                await self._show_flashcard(query.message, user_id)

            elif data == "flashcard_review":
                review_ids = self.user_data.get_needs_review(user_id)
                if not review_ids:
                    await query.answer("ğŸ“‹ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ« Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©!", show_alert=True)
                    return
                FlashcardSystem.start(user_id, review_ids)
                await query.message.edit_text("ğŸƒ Ø¬Ù„Ø³Ø© Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨Ø¯Ø£Øª...")
                await self._show_flashcard(query.message, user_id)

            elif data.startswith("fc_reveal_"):
                hid    = int(data.split("_")[2])
                hadith = self.db.get_by_id(hid)
                if hadith:
                    text, kb = self.fmt.build_flashcard(hadith, show_answer=True)
                    await query.message.edit_text(text, reply_markup=kb, parse_mode=ParseMode.MARKDOWN)

            elif data.startswith("fc_know_"):
                hid = int(data.split("_")[2])
                self.user_data.save_self_assessment(user_id, hid, True)
                self.user_data.increment_flashcard(user_id)
                done = FlashcardSystem.advance(user_id, knew_it=True)
                if done:
                    await self._finish_flashcard(query.message, user_id)
                else:
                    await self._show_flashcard(query.message, user_id)

            elif data.startswith("fc_dontknow_"):
                hid = int(data.split("_")[2])
                self.user_data.save_self_assessment(user_id, hid, False)
                self.user_data.increment_flashcard(user_id)
                done = FlashcardSystem.advance(user_id, knew_it=False)
                if done:
                    await self._finish_flashcard(query.message, user_id)
                else:
                    await self._show_flashcard(query.message, user_id)

            elif data.startswith("fc_skip_"):
                done = FlashcardSystem.advance(user_id, knew_it=False)
                if done:
                    await self._finish_flashcard(query.message, user_id)
                else:
                    await self._show_flashcard(query.message, user_id)

            elif data == "fc_end":
                await self._finish_flashcard(query.message, user_id)

            # â”€â”€ Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data == "selftest_start":
                all_ids = [h["id"] for h in self.db.get_all()]
                random.shuffle(all_ids)
                hadith = self.db.get_by_id(all_ids[0])
                if hadith:
                    await query.message.edit_text("ğŸ¤” Ø¬Ù„Ø³Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°Ø§ØªÙŠ...")
                    await self._show_selftest(query.message, hadith)

            # selftest_{hid} â€” Ø²Ø± "ğŸ¤” Ø£Ø¹Ø±ÙØŸ" Ù…Ù† Ø¯Ø§Ø®Ù„ ØµÙØ­Ø© Ø§Ù„Ø­Ø¯ÙŠØ«
            elif data.startswith("selftest_") and data.count("_") == 1:
                hid    = int(data.split("_")[1])
                hadith = self.db.get_by_id(hid)
                if hadith:
                    await self._show_selftest(query.message, hadith)

            # selftest_know_{hid} â€” Ø¶ØºØ· "âœ… Ø£Ø¹Ø±ÙÙ‡"
            elif data.startswith("selftest_know_"):
                hid  = int(data.split("_")[2])
                self.user_data.save_self_assessment(user_id, hid, True)
                await query.answer("âœ… Ø³Ø¬Ù‘Ù„Øª Ø£Ù†Ùƒ ØªØ¹Ø±ÙÙ‡!")
                all_ids = [h["id"] for h in self.db.get_all()]
                random.shuffle(all_ids)
                next_hadith = self.db.get_by_id(all_ids[0])
                if next_hadith:
                    await self._show_selftest(query.message, next_hadith)

            # selftest_dontknow_{hid} â€” Ø¶ØºØ· "â“ Ù„Ø§ Ø£ØªØ°ÙƒØ±Ù‡"
            elif data.startswith("selftest_dontknow_"):
                hid  = int(data.split("_")[2])
                self.user_data.save_self_assessment(user_id, hid, False)
                await query.answer("ğŸ“‹ Ø³Ø¬Ù‘Ù„Øª Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹")
                all_ids = [h["id"] for h in self.db.get_all()]
                random.shuffle(all_ids)
                next_hadith = self.db.get_by_id(all_ids[0])
                if next_hadith:
                    await self._show_selftest(query.message, next_hadith)

            elif data.startswith("st_explain_"):
                hid    = int(data.split("_")[2])
                hadith = self.db.get_by_id(hid)
                if hadith:
                    status   = await query.message.reply_text("ğŸ’¬ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø´Ø±Ø­...")
                    prompt   = f"Ø§Ø´Ø±Ø­ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø³ÙŠØ·Ø©:\n\n{hadith['text']}"
                    response = await self.ai.generate_response(user_id, prompt, mode="simple", active_hadith=hadith)
                    kb = InlineKeyboardMarkup([[SupportSystem.get_button()]])
                    await status.edit_text(
                        f"ğŸ’¬ *Ø´Ø±Ø­ â€” Ø§Ù„Ø­Ø¯ÙŠØ« {hid}*\n\n{self.fmt.format_response(response)}",
                        reply_markup=kb,
                        parse_mode=ParseMode.MARKDOWN,
                    )

            # view_{hid} â€” Ø²Ø± "ğŸ“– Ø¹Ø±Ø¶ ÙƒØ§Ù…Ù„" Ù…Ù† Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°Ø§ØªÙŠ
            elif data.startswith("view_"):
                hid    = int(data.split("_")[1])
                hadith = self.db.get_by_id(hid)
                if not hadith:
                    await query.answer("âŒ Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
                    return
                status = await query.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¹Ø±Ø¶...")
                await self._display_hadith(user_id, hadith, status)

            # flashcard_{hid} â€” Ø²Ø± "ğŸƒ Ø¨Ø·Ø§Ù‚Ø© Ø­ÙØ¸" Ù…Ù† Ø¯Ø§Ø®Ù„ ØµÙØ­Ø© Ø§Ù„Ø­Ø¯ÙŠØ«
            elif data.startswith("flashcard_"):
                try:
                    hid = int(data.split("_")[1])
                    FlashcardSystem.start(user_id, [hid])
                    await self._show_flashcard(query.message, user_id)
                except (ValueError, IndexError):
                    await query.answer("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£", show_alert=True)

            # â”€â”€ Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data.startswith("plan_"):
                await self._cb_plan(query, user_id, data)

            # â”€â”€ Ø§Ù„ØªÙˆØ§ØµÙ„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data == "feedback_start":
                FeedbackSystem.start(user_id)
                await query.message.reply_text(
                    "ğŸ’¬ *ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§*\n\nØ£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø§Ù„Ø¢Ù† Ø£Ùˆ `/cancel` Ù„Ù„Ø¥Ù„ØºØ§Ø¡.",
                    parse_mode=ParseMode.MARKDOWN,
                )

            # â”€â”€ Ø§Ù„ØªØ°ÙƒÙŠØ± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data == "reminder_menu":
                await self._cb_reminder_menu(query, user_id)

            elif data == "reminder_on":
                self.user_data.enable_reminder(user_id, DEFAULT_REMINDER_TIME)
                await query.message.edit_text(
                    f"âœ… *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ°ÙƒÙŠØ±!*\n\nâ° Ø§Ù„ÙˆÙ‚Øª: {DEFAULT_REMINDER_TIME}\n\n"
                    "Ù„ØªØºÙŠÙŠØ± Ø§Ù„ÙˆÙ‚Øª: `/reminder set HH:MM`",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª",    callback_data="reminder_menu")],
                        [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start")],
                    ]),
                    parse_mode=ParseMode.MARKDOWN,
                )

            elif data == "reminder_off":
                self.user_data.disable_reminder(user_id)
                await query.message.edit_text(
                    "ğŸ”´ *ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ*",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("ğŸŸ¢ ØªÙØ¹ÙŠÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹", callback_data="reminder_on")],
                        [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",     callback_data="start")],
                    ]),
                    parse_mode=ParseMode.MARKDOWN,
                )

            # â”€â”€ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø¹Ø§Ù…Ø© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            elif data == "start":
                await query.message.edit_text(
                    self._WELCOME_TEXT, reply_markup=self._main_keyboard(), parse_mode=ParseMode.MARKDOWN
                )

            elif data == "help":
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start"),
                     InlineKeyboardButton("â° Ø§Ù„ØªØ°ÙƒÙŠØ±",   callback_data="reminder_menu")],
                    [SupportSystem.get_button()],
                ])
                await query.message.edit_text(self._HELP_TEXT, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

            elif data == "list":
                hadiths  = self.db.get_all()
                text     = self.fmt.build_hadith_list(hadiths)
                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="start")]])
                if len(text) <= 4096:
                    await query.message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
                else:
                    await query.message.edit_text("ğŸ“š *Ø§Ù„ÙÙ‡Ø±Ø³:*\n_(ÙŠÙØ±Ø³Ù„ ÙÙŠ Ø£Ø¬Ø²Ø§Ø¡)_", reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
                    for i in range(0, len(text), 4000):
                        await query.message.reply_text(text[i:i+4000], parse_mode=ParseMode.MARKDOWN)

            elif data == "random":
                hadith = self.db.get_random()
                if not hadith:
                    await query.answer("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ«", show_alert=True)
                    return
                await query.message.edit_text("ğŸŒ€ Ø¬Ø§Ø±ÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ÙŠØ«...")
                await self._display_hadith(user_id, hadith, query.message)
                self.user_data.increment_interaction(user_id)
                await self._send_support_if_due(user_id, context.bot)

            elif data == "daily":
                await self._cb_daily(query, user_id, context)

            elif data == "quiz":
                await self._cb_quiz_start(query, user_id)

            elif data == "topics":
                cats     = self.db.get_categories()
                text, kb = self.fmt.build_categories_menu(cats)
                await query.message.edit_text(text, reply_markup=kb, parse_mode=ParseMode.MARKDOWN)

            elif data.startswith("cat_"):
                category = data[4:]  # Ø¥Ø²Ø§Ù„Ø© "cat_"
                await self._cb_category(query, category)

            elif data == "stats":
                stats = self.user_data.get_statistics(user_id, len(self.db))
                text  = self.fmt.build_statistics(stats) + SupportSystem.get_stats_footer()
                await query.message.edit_text(
                    text,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("ğŸ… Ø´Ø§Ø±Ø§ØªÙŠ",    callback_data="badges"),
                         InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start")],
                        [SupportSystem.get_button()],
                    ]),
                    parse_mode=ParseMode.MARKDOWN,
                )

            elif data == "badges":
                earned = set(self.user_data.get_earned_badges(user_id))
                stats  = self.user_data.get_statistics(user_id, len(self.db))
                lines  = ["ğŸ… *Ø´Ø§Ø±Ø§ØªÙƒ ÙˆØ¥Ù†Ø¬Ø§Ø²Ø§ØªÙƒ*\n", "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€\n"]
                for bid, badge in BADGES.items():
                    icon = "âœ…" if bid in earned else "ğŸ”’"
                    lines.append(f"{icon} {badge['emoji']} *{badge['name']}* â€” {badge['desc']}")
                lines.append(f"\nğŸ“Š {len(earned)}/{len(BADGES)} Ø´Ø§Ø±Ø© | ğŸ”¥ {stats['streak']} ÙŠÙˆÙ…")
                await query.message.edit_text(
                    "\n".join(lines),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="stats"),
                         InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start")],
                    ]),
                    parse_mode=ParseMode.MARKDOWN,
                )

            elif data == "favorites":
                await self._cb_favorites(query, user_id)

            elif data == "plan":
                await self._cb_plan_menu(query, user_id)

        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ button_handler [{data}]: {exc}", exc_info=True)
            try:
                await query.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
            except Exception:
                pass

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ© (private)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def _cb_favorite(self, query, user_id: int, hadith_id: int) -> None:
        if self.user_data.is_favorite(user_id, hadith_id):
            self.user_data.remove_favorite(user_id, hadith_id)
            await query.answer("â˜† ØªÙ…Øª Ø§Ù„Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©")
        else:
            self.user_data.add_favorite(user_id, hadith_id)
            await query.answer("â­ ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…ÙØ¶Ù„Ø©")
        is_fav  = self.user_data.is_favorite(user_id, hadith_id)
        has_note = self.user_data.get_note(user_id, hadith_id) is not None
        _, new_kb = self.fmt.build_hadith_display(
            self.db.get_by_id(hadith_id), include_actions=True, is_favorite=is_fav, has_note=has_note
        )
        try:
            await query.message.edit_reply_markup(reply_markup=new_kb)
        except Exception:
            pass
        # ØªØ­Ù‚Ù‚ Ù…Ù† Ø´Ø§Ø±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
        new_badges = self.user_data.check_and_award_badges(user_id)
        if new_badges:
            for b in new_badges:
                if b in BADGES:
                    await query.message.reply_text(
                        f"ğŸ‰ *Ø´Ø§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©!*\n{BADGES[b]['emoji']} *{BADGES[b]['name']}*",
                        parse_mode=ParseMode.MARKDOWN,
                    )

    async def _cb_note(self, query, user_id: int, hadith_id: int) -> None:
        current_note = self.user_data.get_note(user_id, hadith_id)
        NoteSystem.start(user_id, hadith_id)
        if current_note:
            text = (
                f"ğŸ“ *Ù…Ù„Ø§Ø­Ø¸ØªÙƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ÙŠØ« {hadith_id}:*\n\n"
                f"{MessageFormatter.esc(current_note)}\n\n"
                "âœï¸ *Ø£Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„ØªØ­Ø¯ÙŠØ«Ù‡Ø§*\nØ£Ùˆ `/cancel` Ù„Ù„Ø¥Ù„ØºØ§Ø¡"
            )
        else:
            text = (
                f"ğŸ“ *Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ÙŠØ« {hadith_id}*\n\n"
                "âœï¸ *Ø£Ø±Ø³Ù„ Ù…Ù„Ø§Ø­Ø¸ØªÙƒ Ø§Ù„Ø¢Ù†*\nØ£Ùˆ `/cancel` Ù„Ù„Ø¥Ù„ØºØ§Ø¡"
            )
        await query.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)

    async def _handle_note_input(self, update: Update, user_id: int) -> None:
        hadith_id = NoteSystem.get_hadith_id(user_id)
        NoteSystem.stop(user_id)
        note_text = update.message.text.strip()
        if not note_text:
            await update.message.reply_text("âŒ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© ÙØ§Ø±ØºØ©.")
            return
        if self.user_data.add_note(user_id, hadith_id, note_text):
            await update.message.reply_text(
                f"âœ… *ØªÙ… Ø­ÙØ¸ Ù…Ù„Ø§Ø­Ø¸ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø¯ÙŠØ« {hadith_id}!*\n\n{MessageFormatter.esc(note_text)}",
                parse_mode=ParseMode.MARKDOWN,
            )
            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©
            await asyncio.sleep(1)
            await MonetagSystem.send_ad(
                update.get_bot(),
                chat_id=user_id,
                context_label="ğŸ“ *ØªÙ… Ø­ÙØ¸ Ù…Ù„Ø§Ø­Ø¸ØªÙƒ!*",
            )
            # ØªØ­Ù‚Ù‚ Ù…Ù† Ø´Ø§Ø±Ø© Ø§Ù„ÙƒØ§ØªØ¨
            new_badges = self.user_data.check_and_award_badges(user_id)
            if new_badges and "writer" in new_badges:
                await update.message.reply_text(
                    f"ğŸ‰ *Ø´Ø§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©!*\nğŸ“ *Ø§Ù„ÙƒØ§ØªØ¨* â€” ÙƒØªØ¨Øª 10 Ù…Ù„Ø§Ø­Ø¸Ø§Øª!",
                    parse_mode=ParseMode.MARKDOWN,
                )
        else:
            await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©.")

    async def _cb_related(self, query, user_id: int, hadith_id: int) -> None:
        related = self.db.get_related(hadith_id, limit=4)
        if not related:
            await query.message.reply_text("Ù„Ù… Ø£Ø¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ« Ù…Ø±ØªØ¨Ø·Ø©.")
            return
        lines = ["ğŸ”— *Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©:*\n"]
        lines.extend(f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {h['id']}: {h['title']}" for h in related)
        lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡")
        keyboard = InlineKeyboardMarkup([[SupportSystem.get_button()]])
        await query.message.reply_text("\n".join(lines), reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    async def _cb_narrator(self, query, hadith_id: int) -> None:
        """Ø¹Ø±Ø¶ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ"""
        hadith = self.db.get_by_id(hadith_id)
        if not hadith:
            await query.answer("âŒ Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
            return
        narrator_full = hadith.get("narrator_full", {})
        keyboard = InlineKeyboardMarkup([[SupportSystem.get_button()]])
        if not narrator_full:
            await query.message.reply_text(
                f"ğŸ‘¤ *Ø§Ù„Ø±Ø§ÙˆÙŠ:* {MessageFormatter.esc(hadith['narrator'])}",
                reply_markup=keyboard,
                parse_mode=ParseMode.MARKDOWN,
            )
            return
        card = self.fmt.build_narrator_card(narrator_full)
        await query.message.reply_text(card, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    async def _cb_english(self, query, hadith_id: int) -> None:
        """Ø¹Ø±Ø¶ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©"""
        hadith = self.db.get_by_id(hadith_id)
        if not hadith:
            await query.answer("âŒ Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
            return
        if not hadith.get("english_text"):
            await query.answer("âš ï¸ Ø§Ù„ØªØ±Ø¬Ù…Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ«", show_alert=True)
            return
        text = self.fmt.build_english_display(hadith)
        keyboard = InlineKeyboardMarkup([[SupportSystem.get_button()]])
        await query.message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    async def _cb_share(self, query, hadith_id: int) -> None:
        """Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø­Ø¯ÙŠØ« Ø¨ØµÙŠØºØ© Ø¬Ø§Ù‡Ø²Ø©"""
        hadith = self.db.get_by_id(hadith_id)
        if not hadith:
            await query.answer("âŒ Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
            return
        text = self.fmt.build_share_text(hadith)
        keyboard = InlineKeyboardMarkup([[SupportSystem.get_button()]])
        await query.message.reply_text(text, reply_markup=keyboard)

    async def _cb_simple(self, query, user_id: int, hadith_id: int) -> None:
        hadith = self.db.get_by_id(hadith_id)
        if not hadith:
            return
        status   = await query.message.reply_text("ğŸ’¬ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø´Ø±Ø­ Ø§Ù„Ù…Ø¨Ø³Ø·...")
        prompt   = f"Ø§Ø´Ø±Ø­ Ø§Ù„Ø­Ø¯ÙŠØ« Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø³ÙŠØ·Ø© Ù„Ù„Ø£Ø·ÙØ§Ù„ ÙˆØ§Ù„Ù…Ø¨ØªØ¯Ø¦ÙŠÙ†:\n\n{hadith['text']}"
        response = await self.ai.generate_response(user_id, prompt, mode="simple", active_hadith=hadith)
        keyboard = InlineKeyboardMarkup([[SupportSystem.get_button()]])
        await status.edit_text(
            f"ğŸ’¬ *Ø´Ø±Ø­ Ù…Ø¨Ø³Ø· â€” Ø§Ù„Ø­Ø¯ÙŠØ« {hadith_id}*\n\n{self.fmt.format_response(response)}",
            reply_markup=keyboard,
            parse_mode=ParseMode.MARKDOWN,
        )

    async def _cb_compare(self, query, user_id: int, hadith_id: int) -> None:
        hadith = self.db.get_by_id(hadith_id)
        if not hadith:
            await query.answer("âŒ Ø§Ù„Ø­Ø¯ÙŠØ« ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
            return
        try:
            status   = await query.message.reply_text("ğŸ“– Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø´Ø±ÙˆØ­Ø§Øª...")
            prompt   = f"Ù‚Ø¯Ù… Ø´Ø±Ø­Ø§Ù‹ Ù…Ù‚Ø§Ø±Ù†Ø§Ù‹ Ù…ØªØ¹Ù…Ù‚Ø§Ù‹ Ù„Ù„Ø­Ø¯ÙŠØ« Ø§Ù„ØªØ§Ù„ÙŠ:\n\n{hadith['text']}"
            response = await self.ai.generate_response(user_id, prompt, mode="compare", active_hadith=hadith)
            formatted = self.fmt.format_response(response)
            full      = f"ğŸ“– *Ø´Ø±Ø­ Ù…ØªØ¹Ù…Ù‚ â€” Ø§Ù„Ø­Ø¯ÙŠØ« {hadith_id}*\n\n{formatted}"
            keyboard  = InlineKeyboardMarkup([[SupportSystem.get_button()]])
            if len(full) > 4096:
                await status.edit_text(full[:4093] + "...", reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
                await query.message.reply_text("..." + full[4093:], parse_mode=ParseMode.MARKDOWN)
            else:
                await status.edit_text(full, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ _cb_compare: {exc}")
            await query.answer("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£")

    async def _cb_category(self, query, category: str) -> None:
        """[Ø¬Ø¯ÙŠØ¯] Ø¹Ø±Ø¶ Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„ØªØµÙ†ÙŠÙ"""
        # Ù†Ù†Ø¸Ø± Ø¹Ø¨Ø± ÙƒÙ„ Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª Ø¨Ù…Ø§ ÙŠØ¨Ø¯Ø£ Ø¨Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ù‚ØµÙˆØµ
        cats = self.db.get_categories()
        # Ø¬Ø±Ù‘Ø¨ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„ØªØ§Ù…Ø© Ø£ÙˆÙ„Ø§Ù‹
        hadiths = self.db.get_by_category(category)
        if not hadiths:
            # Ø¥Ø°Ø§ Ù‚ÙØµÙ‘ Ø§Ù„Ù…ÙØªØ§Ø­ØŒ Ø§Ø¨Ø­Ø« Ø¨Ø§Ù„Ø¨Ø§Ø¯Ø¦Ø©
            for cat_name, ids in cats.items():
                if cat_name.startswith(category):
                    hadiths = [self.db.get_by_id(i) for i in ids]
                    hadiths = [h for h in hadiths if h]
                    category = cat_name
                    break
        if not hadiths:
            await query.answer("âŒ Ù„Ù… Ø£Ø¬Ø¯ Ø£Ø­Ø§Ø¯ÙŠØ« ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ØªØµÙ†ÙŠÙ", show_alert=True)
            return
        lines = [f"ğŸ·ï¸ *{category}*\n"]
        for h in hadiths:
            badge = " âœ¨" if h.get("hadith_type") == "qudsi" else ""
            lines.append(f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {h['id']}: {h['title']}{badge}")
        lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡")
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("â†©ï¸ Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª",  callback_data="topics"),
             InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",   callback_data="start")],
            [SupportSystem.get_button()],
        ])
        await query.message.edit_text("\n".join(lines), reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    # â”€â”€ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _show_quiz_question(self, message, user_id: int) -> None:
        question = QuizSystem.get_current_question(user_id)
        if not question:
            await self._finish_quiz(message, user_id, is_callback=False)
            return
        quiz    = QuizSystem.active_quizzes[user_id]
        current = quiz["current_index"] + 1
        total   = len(quiz["questions"])
        emoji   = QuizSystem._TYPE_EMOJI.get(question["type"], "â“")
        text    = f"{emoji} *Ø³Ø¤Ø§Ù„ {current} Ù…Ù† {total}*\n\n{question['question']}"
        buttons = []
        for i, opt in enumerate(question["options"]):
            label = opt if len(opt) <= 60 else opt[:57] + "..."
            buttons.append([InlineKeyboardButton(label, callback_data=f"quiz_answer_{i}")])
        await message.reply_text(text, reply_markup=InlineKeyboardMarkup(buttons), parse_mode=ParseMode.MARKDOWN)

    async def _finish_quiz(self, message, user_id: int, is_callback: bool) -> None:
        result = QuizSystem.get_result(user_id)
        if not result:
            return
        self.user_data.save_quiz_score(user_id, result["score"], result["total"])
        text = QuizSystem.build_result_text(result)
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ“ Ø§Ø®ØªØ¨Ø§Ø± Ø¬Ø¯ÙŠØ¯", callback_data="quiz"),
             InlineKeyboardButton("ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ",  callback_data="stats")],
            [SupportSystem.get_button()],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",   callback_data="start")],
        ])
        await message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        # ØªØ­Ù‚Ù‚ Ù…Ù† Ø´Ø§Ø±Ø© Ø§Ù„Ø­Ø§ÙØ¸
        new_badges = self.user_data.check_and_award_badges(user_id)
        if new_badges and "champion" in new_badges:
            await message.reply_text(
                "ğŸ‰ *Ø´Ø§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø©!*\nğŸ† *Ø§Ù„Ø­Ø§ÙØ¸* â€” Ù†ØªÙŠØ¬Ø© 100% ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø±!",
                parse_mode=ParseMode.MARKDOWN,
            )

        # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
        await asyncio.sleep(1)
        await MonetagSystem.send_ad(
            message.get_bot() if hasattr(message, "get_bot") else message._bot,
            chat_id=user_id,
            context_label="âœ… *Ø£Ø­Ø³Ù†Øª! Ø¥Ù„ÙŠÙƒ Ø´ÙŠØ¡ Ù‚Ø¯ ÙŠÙ‡Ù…Ùƒ*",
        )

    async def _cb_quiz_answer(self, query, user_id: int, option_index: int) -> None:
        try:
            question = QuizSystem.get_current_question(user_id)
            if not question:
                await query.answer("Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±")
                return
            if option_index < 0 or option_index >= len(question["options"]):
                await query.answer("âŒ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ­ÙŠØ­")
                return
            selected_answer         = question["options"][option_index]
            is_correct, correct_ans = QuizSystem.submit_answer(user_id, selected_answer)
            await query.answer("âœ… ØµØ­ÙŠØ­!" if is_correct else "âŒ Ø®Ø·Ø£")
            if is_correct:
                await query.message.reply_text("âœ… Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! Ù…Ù…ØªØ§Ø²!")
            else:
                await query.message.reply_text(
                    f"âŒ Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©.\n\n*Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©:*\n{correct_ans}",
                    parse_mode=ParseMode.MARKDOWN,
                )
            await asyncio.sleep(0.5)
            if QuizSystem.get_current_question(user_id):
                await self._show_quiz_question(query.message, user_id)
            else:
                await self._finish_quiz(query.message, user_id, is_callback=True)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ _cb_quiz_answer: {exc}", exc_info=True)
            await query.answer("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£")

    async def _cb_quiz_start(self, query, user_id: int) -> None:
        if QuizSystem.is_active(user_id):
            await query.answer("âš ï¸ Ù„Ø¯ÙŠÙƒ Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø´Ø·!", show_alert=True)
            return
        questions = QuizSystem.generate_quiz(self.db, question_count=5)
        if not questions:
            await query.answer("âŒ ØªØ¹Ø°Ù‘Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±", show_alert=True)
            return
        QuizSystem.start(user_id, questions)
        await query.message.edit_text("ğŸ“ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±...")
        await self._show_quiz_question(query.message, user_id)

    # â”€â”€ Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø­ÙØ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _show_flashcard(self, message, user_id: int) -> None:
        hid = FlashcardSystem.get_current(user_id)
        if hid is None:
            await self._finish_flashcard(message, user_id)
            return
        hadith = self.db.get_by_id(hid)
        if not hadith:
            FlashcardSystem.advance(user_id, False)
            await self._show_flashcard(message, user_id)
            return
        session = FlashcardSystem._sessions.get(user_id, {})
        idx   = session.get("index", 0)
        total = session.get("total", 1)
        text, kb = self.fmt.build_flashcard(hadith)
        header   = f"ğŸƒ *Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© {idx + 1} Ù…Ù† {total}*\n\n"
        try:
            await message.edit_text(header + text, reply_markup=kb, parse_mode=ParseMode.MARKDOWN)
        except Exception:
            await message.reply_text(header + text, reply_markup=kb, parse_mode=ParseMode.MARKDOWN)

    async def _finish_flashcard(self, message, user_id: int) -> None:
        session = FlashcardSystem.get_result(user_id)
        if not session:
            await message.reply_text("âœ… Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª!")
            return
        correct = session.get("correct", 0)
        total   = session.get("total", 0)
        pct     = round((correct / total) * 100) if total else 0
        text = (
            f"ğŸƒ *Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª!*\n\n"
            f"âœ… Ø­ÙØ¸Øª: {correct}/{total}\n"
            f"ğŸ“Š Ø§Ù„Ù†Ø³Ø¨Ø©: {pct}%\n\n"
        )
        if pct >= 80:
            text += "ğŸŒŸ Ù…Ù…ØªØ§Ø²! Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø°Ø§ÙƒØ±Ø©!"
        else:
            text += "ğŸ’ª Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„ØªÙŠ Ù„Ù… ØªØªØ°ÙƒØ±Ù‡Ø§!"
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸ“‹ Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©", callback_data="flashcard_review")],
            [SupportSystem.get_button()],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",         callback_data="start")],
        ])
        try:
            await message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        except Exception:
            await message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        # ØªØ­Ù‚Ù‚ Ù…Ù† Ø´Ø§Ø±Ø§Øª
        self.user_data.check_and_award_badges(user_id)

        # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø¬Ù„Ø³Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
        await asyncio.sleep(1)
        try:
            bot = message.get_bot() if hasattr(message, "get_bot") else message._bot
            await MonetagSystem.send_ad(
                bot,
                chat_id=user_id,
                context_label="ğŸ“š *Ø¬Ù„Ø³Ø© Ø±Ø§Ø¦Ø¹Ø©! Ø¥Ù„ÙŠÙƒ Ø´ÙŠØ¡ Ù‚Ø¯ ÙŠÙ‡Ù…Ùƒ*",
            )
        except Exception:
            pass

    # â”€â”€ Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¹Ø±Ù/Ù„Ø§ Ø£Ø¹Ø±Ù â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _show_selftest(self, message, hadith: Dict[str, Any]) -> None:
        hid  = hadith["id"]
        body = hadith.get("hadith_text_only") or hadith.get("text", "")
        text = (
            f"ğŸ¤” *Ù‡Ù„ ØªØ¹Ø±Ù Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¯ÙŠØ«ØŸ*\n\n"
            f"ğŸ“– *{MessageFormatter.esc(hadith['title'])}*\n\n"
            f"Â«{MessageFormatter.esc(body[:250])}Â»\n\n"
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        )
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("âœ… Ø£Ø¹Ø±ÙÙ‡",           callback_data=f"selftest_know_{hid}"),
                InlineKeyboardButton("â“ Ù„Ø§ Ø£ØªØ°ÙƒØ±Ù‡",       callback_data=f"selftest_dontknow_{hid}"),
            ],
            [
                InlineKeyboardButton("ğŸ’¬ Ø§Ø´Ø±Ø­Ù‡ Ù„ÙŠ",       callback_data=f"st_explain_{hid}"),
                InlineKeyboardButton("ğŸ“– Ø¹Ø±Ø¶ ÙƒØ§Ù…Ù„",        callback_data=f"view_{hid}"),
            ],
            [SupportSystem.get_button()],
            [InlineKeyboardButton("ğŸšª Ø¥Ù†Ù‡Ø§Ø¡",              callback_data="start")],
        ])
        try:
            await message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        except Exception:
            await message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    # â”€â”€ Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _cb_plan(self, query, user_id: int, data: str) -> None:
        if data == "plan_reset":
            self.user_data.set_study_plan(user_id, [])
            await query.message.edit_text(
                "ğŸ”„ *Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø©*\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¯Ø©:",
                reply_markup=self._plan_choice_keyboard(),
                parse_mode=ParseMode.MARKDOWN,
            )
            return
        days    = int(data.split("_")[1])
        all_ids = list(range(1, len(self.db) + 1))
        random.shuffle(all_ids)
        self.user_data.set_study_plan(user_id, all_ids)
        rate    = round(len(all_ids) / days, 1)
        await query.message.edit_text(
            f"ğŸ¯ *ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·ØªÙƒ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©!*\n\n"
            f"ğŸ“… Ø§Ù„Ù…Ø¯Ø©: {days} ÙŠÙˆÙ…\n"
            f"ğŸ“š Ø§Ù„Ù…Ø¹Ø¯Ù„: ~{rate} Ø­Ø¯ÙŠØ«/ÙŠÙˆÙ…\n"
            f"ğŸ“– Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«: {len(all_ids)}\n\n"
            "ğŸ’¡ Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« ÙˆØ³ÙŠØªØªØ¨Ø¹ Ø§Ù„Ø¨ÙˆØª ØªÙ‚Ø¯Ù…Ùƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹!",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“Š Ø¹Ø±Ø¶ ØªÙ‚Ø¯Ù…ÙŠ", callback_data="plan")],
                [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start")],
            ]),
            parse_mode=ParseMode.MARKDOWN,
        )

    async def _cb_plan_menu(self, query, user_id: int) -> None:
        cur_plan = self.user_data.get_study_plan(user_id)
        try:
            if not cur_plan:
                await query.message.edit_text(
                    "ğŸ¯ *Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·Ø© Ø¯Ø±Ø§Ø³ÙŠØ©*\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¯Ø©:",
                    reply_markup=self._plan_choice_keyboard(),
                    parse_mode=ParseMode.MARKDOWN,
                )
            else:
                text     = self._build_plan_text(user_id, cur_plan)
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ”„ Ø®Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø©", callback_data="plan_reset")],
                    [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©",  callback_data="start")],
                ])
                await query.message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ _cb_plan_menu: {exc}")
            await query.answer("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£", show_alert=True)

    # â”€â”€ Ø§Ù„ØªØ°ÙƒÙŠØ± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _cb_reminder_menu(self, query, user_id: int) -> None:
        settings = self.user_data.get_reminder_settings(user_id)
        status   = "ğŸŸ¢ Ù…ÙØ¹Ù‘Ù„" if settings["enabled"] else "ğŸ”´ Ù…Ø¹Ø·Ù‘Ù„"
        evening  = settings.get("time_evening") or "ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„"
        text = (
            "â° *Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ*\n\n"
            f"*Ø§Ù„Ø­Ø§Ù„Ø©:* {status}\n"
            f"*Ø§Ù„ØµØ¨Ø§Ø­ÙŠ:* {settings['time']}\n"
            f"*Ø§Ù„Ù…Ø³Ø§Ø¦ÙŠ:* {evening}\n\n"
            "Ø§Ø³ØªØ®Ø¯Ù… `/reminder` Ù„Ù„ØªØ­ÙƒÙ… Ø§Ù„ÙƒØ§Ù…Ù„"
        )
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("ğŸŸ¢ ØªÙØ¹ÙŠÙ„",   callback_data="reminder_on"),
             InlineKeyboardButton("ğŸ”´ ØªØ¹Ø·ÙŠÙ„",  callback_data="reminder_off")],
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="start")],
        ])
        await query.message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    # â”€â”€ Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _cb_daily(self, query, user_id: int, context: ContextTypes.DEFAULT_TYPE) -> None:
        today = datetime.now().date().isoformat()
        if self.user_data.get_last_daily(user_id) == today:
            await query.answer("ğŸ“… Ù„Ù‚Ø¯ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… Ø¨Ø§Ù„ÙØ¹Ù„!", show_alert=True)
            return
        unread    = self.user_data.get_unread_hadiths(user_id, len(self.db))
        hadith_id = random.choice(unread) if unread else random.randint(1, len(self.db))
        hadith    = self.db.get_by_id(hadith_id)
        if hadith:
            await query.message.edit_text("ğŸ“… Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…...")
            self.user_data.update_last_daily(user_id)
            remaining = len(unread) - 1 if unread else 0
            prefix    = f"ğŸ“… *Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…*\nğŸ“š ØªØ¨Ù‚Ù‰ {remaining} Ø­Ø¯ÙŠØ«Ø§Ù‹ Ù„Ù„Ø¥ØªÙ…Ø§Ù…!\n\n"
            await self._display_hadith(user_id, hadith, query.message, prefix=prefix)
            self.user_data.increment_interaction(user_id)
            await self._send_support_if_due(user_id, context.bot)

            # ğŸ“¢ Ø¥Ø¹Ù„Ø§Ù† Monetag Ø¨Ø¹Ø¯ Ø­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ… â€” Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ ÙÙ‚Ø·
            await asyncio.sleep(2)
            await MonetagSystem.send_ad(
                context.bot,
                chat_id=user_id,
                context_label="ğŸŒŸ *Ø¬Ø²Ø§Ùƒ Ø§Ù„Ù„Ù‡ Ø®ÙŠØ±Ø§Ù‹ Ø¹Ù„Ù‰ Ù‚Ø±Ø§Ø¡ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ÙŠØ©*",
            )

    # â”€â”€ Ø§Ù„Ù…ÙØ¶Ù„Ø© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _cb_favorites(self, query, user_id: int) -> None:
        favorites = self.user_data.get_favorites(user_id)
        if not favorites:
            text = (
                "â­ *Ø§Ù„Ù…ÙØ¶Ù„Ø© ÙØ§Ø±ØºØ©*\n\n"
                "Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ø¶Ø§ÙØ© Ø£ÙŠ Ø­Ø¯ÙŠØ« Ù„Ù„Ù…ÙØ¶Ù„Ø© Ø¨Ø¹Ø¯.\n"
                "Ø¹Ù†Ø¯ Ø¹Ø±Ø¶ Ø£ÙŠ Ø­Ø¯ÙŠØ«ØŒ Ø§Ø¶ØºØ· â˜† Ù„Ø¥Ø¶Ø§ÙØªÙ‡."
            )
        else:
            lines = ["â­ *Ø£Ø­Ø§Ø¯ÙŠØ«Ùƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©:*\n"]
            for hid in favorites:
                h = self.db.get_by_id(hid)
                if h:
                    lines.append(f"â€¢ Ø§Ù„Ø­Ø¯ÙŠØ« {hid}: {h['title']}")
            lines.append("\nğŸ’¡ Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø¯ÙŠØ« Ù„Ø¹Ø±Ø¶Ù‡")
            text = "\n".join(lines)
        keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="start")]])
        await query.message.edit_text(text, reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN)

    # â”€â”€ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _handle_feedback_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user    = update.effective_user
        user_id = user.id
        FeedbackSystem.stop(user_id)
        msg_text = update.message.text
        safe_name = MessageFormatter.esc(user.first_name or "")
        safe_msg  = MessageFormatter.esc(msg_text or "")
        dev_msg  = (
            "ğŸ“¨ *Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ù…Ø³ØªØ®Ø¯Ù… Ù†Ø¨Ø±Ø§Ø³*\n\n"
            f"ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* {safe_name}"
        )
        if user.username:
            dev_msg += f" (@{user.username})"
        dev_msg += f"\nğŸ†” *Ø§Ù„Ù…Ø¹Ø±Ù:* `{user_id}`\n\nğŸ’¬ *Ø§Ù„Ø±Ø³Ø§Ù„Ø©:*\n{safe_msg}"
        try:
            if DEVELOPER_TELEGRAM_ID:
                # Ø²Ø± Ø±Ø¯ Ù…Ø¨Ø§Ø´Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                reply_keyboard = InlineKeyboardMarkup([[
                    InlineKeyboardButton(
                        f"â†©ï¸ Ø±Ø¯ Ø¹Ù„Ù‰ {user.first_name or user_id}",
                        callback_data=f"admin_reply_{user_id}"
                    )
                ]])
                await context.bot.send_message(
                    chat_id=int(DEVELOPER_TELEGRAM_ID),
                    text=dev_msg,
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup=reply_keyboard,
                )
                await update.message.reply_text(
                    "âœ… *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!*\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ùƒ! ğŸ™",
                    parse_mode=ParseMode.MARKDOWN,
                )
            else:
                await update.message.reply_text("âš ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØ§ØµÙ„ ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹.")
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©: {exc}")
            await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ.")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 11. Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    import telegram.error as tg_err

    # âœ… ØªØ¹Ø§Ù…Ù„ Ø®Ø§Øµ Ù…Ø¹ Ø®Ø·Ø£ ØªØ¹Ø§Ø±Ø¶ Ø§Ù„Ù†Ø³Ø® â€” Ù„Ø§ ÙŠÙØ±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    if isinstance(context.error, tg_err.Conflict):
        logger.critical(
            "âš ï¸ ØªØ¹Ø§Ø±Ø¶: Ù†Ø³Ø®ØªØ§Ù† Ù…Ù† Ø§Ù„Ø¨ÙˆØª ØªØ¹Ù…Ù„Ø§Ù† ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª! "
            "Ø£ÙˆÙ‚Ù Ø¥Ø­Ø¯Ø§Ù‡Ù…Ø§ Ø¹Ù„Ù‰ Render ÙÙˆØ±Ø§Ù‹."
        )
        return

    # âœ… ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† Ø­Ø¬Ø¨ÙˆØ§ Ø§Ù„Ø¨ÙˆØª
    if isinstance(context.error, tg_err.Forbidden):
        logger.warning(f"Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø¬Ø¨ Ø§Ù„Ø¨ÙˆØª: {context.error}")
        return

    # âœ… ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø´Ø¨ÙƒÙŠØ© Ø¨Ù‡Ø¯ÙˆØ¡
    if isinstance(context.error, tg_err.NetworkError):
        logger.warning(f"Ø®Ø·Ø£ Ø´Ø¨ÙƒÙŠ Ù…Ø¤Ù‚Øª: {context.error}")
        return

    logger.error(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø§Ù„ÙØ¬: {context.error}", exc_info=context.error)
    try:
        if update and update.effective_message:
            await update.effective_message.reply_text(
                "ğŸ˜” Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹.\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
            )
    except Exception as exc:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {exc}")


async def reminder_loop(bot, user_data_mgr, hadith_db) -> None:
    """Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ÙŠÙˆÙ…ÙŠ â€” ØªØ¹Ù…Ù„ ÙÙŠ Ø®Ù„ÙÙŠØ© asyncio ÙƒÙ„ 60 Ø«Ø§Ù†ÙŠØ© Ø¨Ø¯ÙˆÙ† job_queue"""
    logger.info("â° Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± Ø¨Ø¯Ø£Øª")
    while True:
        try:
            await asyncio.sleep(60)
            users = user_data_mgr.get_all_users_with_reminders()
            # âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… UTC timezone-aware Ø¨Ø¯Ù„ naive datetime
            from datetime import timezone as dt_timezone
            now = datetime.now(dt_timezone.utc)
            for user_id, settings in users:
                tz_str = settings.get("timezone", DEFAULT_TIMEZONE)
                try:
                    tz     = ZoneInfo(tz_str)
                    now_tz = now.astimezone(tz)
                    cur_min = now_tz.hour * 60 + now_tz.minute

                    # â”€â”€ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ØµØ¨Ø§Ø­ÙŠ â”€â”€
                    time_str = settings.get("time", DEFAULT_REMINDER_TIME)
                    rem_time = ReminderSystem.parse_time(time_str)
                    if rem_time:
                        rem_min = rem_time.hour * 60 + rem_time.minute
                        # âœ… Ø¥ØµÙ„Ø§Ø­: ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ù†Ø§ÙØ°Ø© Ù…Ù† 2 Ø¥Ù„Ù‰ 3 Ø¯Ù‚Ø§Ø¦Ù‚ Ù„ØªÙØ§Ø¯ÙŠ Ø§Ù„ØªÙÙˆÙŠØª
                        if abs(cur_min - rem_min) < 3 and ReminderSystem.should_send(settings.get("last_sent"), tz_str):
                            unread    = user_data_mgr.get_unread_hadiths(user_id, len(hadith_db))
                            hadith_id = random.choice(unread) if unread else random.randint(1, len(hadith_db))
                            hadith    = hadith_db.get_by_id(hadith_id)
                            if hadith:
                                await bot.send_message(
                                    chat_id=user_id,
                                    text=ReminderSystem.build_message(hadith, len(unread)),
                                    parse_mode=ParseMode.MARKDOWN,
                                )
                                user_data_mgr.update_last_reminder_sent(user_id, evening=False)
                                logger.info(f"ğŸ“¨ ØªØ°ÙƒÙŠØ± ØµØ¨Ø§Ø­ÙŠ â†’ {user_id}")

                    # â”€â”€ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„Ù…Ø³Ø§Ø¦ÙŠ â”€â”€
                    evening_str = settings.get("time_evening")
                    if evening_str:
                        ev_time = ReminderSystem.parse_time(evening_str)
                        if ev_time:
                            ev_min = ev_time.hour * 60 + ev_time.minute
                            # âœ… Ø¥ØµÙ„Ø§Ø­: ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ù†Ø§ÙØ°Ø© Ù…Ù† 2 Ø¥Ù„Ù‰ 3 Ø¯Ù‚Ø§Ø¦Ù‚
                            if abs(cur_min - ev_min) < 3 and ReminderSystem.should_send(settings.get("last_evening"), tz_str):
                                hadith = hadith_db.get_random()
                                if hadith:
                                    await bot.send_message(
                                        chat_id=user_id,
                                        text=ReminderSystem.build_evening_message(hadith),
                                        parse_mode=ParseMode.MARKDOWN,
                                    )
                                    user_data_mgr.update_last_reminder_sent(user_id, evening=True)
                                    logger.info(f"ğŸŒ™ ØªØ°ÙƒÙŠØ± Ù…Ø³Ø§Ø¦ÙŠ â†’ {user_id}")
                except Exception as exc:
                    logger.error(f"Ø®Ø·Ø£ ØªØ°ÙƒÙŠØ± {user_id}: {exc}")
        except asyncio.CancelledError:
            logger.info("â° Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± Ø£ÙÙˆÙ‚ÙØª")
            break
        except Exception as exc:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ±: {exc}")


async def _run_bot() -> None:
    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± ÙÙŠ asyncio"""
    validate_configuration()

    logger.info("ğŸ”§ Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª...")
    hadith_db     = HadithDatabase(HADITH_FILE_PATH)
    user_data_mgr = UserDataManager(USER_DATA_PATH)
    memory        = ConversationMemory()
    formatter     = MessageFormatter()
    ai_engine     = NibrasAI(OPENROUTER_API_KEY, GOOGLE_API_KEY, memory)
    handlers      = BotHandlers(hadith_db, user_data_mgr, ai_engine, formatter)

    logger.info("ğŸ¤– Ø¬Ø§Ø±ÙŠ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª...")
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    # â”€â”€ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø± â”€â”€
    for cmd, fn in [
        ("start",       handlers.start_command),
        ("help",        handlers.help_command),
        ("list",        handlers.list_command),
        ("random",      handlers.random_command),
        ("search",      handlers.search_command),
        ("topics",      handlers.topics_command),
        ("stats",       handlers.stats_command),
        ("badges",      handlers.badges_command),
        ("favorites",   handlers.favorites_command),
        ("review",      handlers.review_command),
        ("daily",       handlers.daily_command),
        ("quiz",        handlers.quiz_command),
        ("cancel_quiz", handlers.cancel_quiz_command),
        ("flashcard",   handlers.flashcard_command),
        ("selftest",    handlers.selftest_command),
        ("plan",        handlers.plan_command),
        ("note",        handlers.note_command),
        ("feedback",    handlers.feedback_command),
        ("reminder",    handlers.reminder_command),
        ("cancel",      handlers.cancel_command),
        # â”€â”€ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø´Ø±Ù (Ù…Ø®ÙÙŠØ©) â”€â”€
        ("admin_help",      handlers.admin_help_command),
        ("admin_stats",     handlers.admin_stats_command),
        ("admin_broadcast", handlers.admin_broadcast_command),
        ("admin_ban",       handlers.admin_ban_command),
        ("admin_unban",     handlers.admin_unban_command),
        ("admin_export",    handlers.admin_export_command),
        ("admin_user",      handlers.admin_user_command),
        ("admin_top",        handlers.admin_top_command),
        ("admin_inactive",   handlers.admin_inactive_command),
        ("admin_announce",   handlers.admin_announce_command),
        ("admin_maintenance",handlers.admin_maintenance_command),
    ]:
        app.add_handler(CommandHandler(cmd, fn))

    app.add_handler(CallbackQueryHandler(handlers.button_handler))
    app.add_handler(MessageHandler(filters.ALL, handlers.message_handler))
    app.add_error_handler(error_handler)

    print("\n" + "=" * 65)
    print("ğŸŒŸ Ø¨ÙˆØª Ù†Ø¨Ø±Ø§Ø³ v3 â€” Ù…Ø¹Ù„Ù… Ø§Ù„Ø£Ø±Ø¨Ø¹ÙŠÙ† Ø§Ù„Ù†ÙˆÙˆÙŠØ©")
    print("=" * 65)
    print(f"âœ… ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­! | ğŸ“š Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ«: {len(hadith_db)}")
    print(f"ğŸ·ï¸ Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª: {len(hadith_db.get_categories())}")
    print("ğŸ†• Ø§Ù„Ù…ÙŠØ²Ø§Øª: Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø§ÙˆÙŠ | Ø§Ù„ØªØ±Ø¬Ù…Ø© | Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª | Ø§Ù„Ø´Ø§Ø±Ø§Øª | Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª")
    print("â¸ï¸  Ø§Ø¶ØºØ· Ctrl+C Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù")
    print("=" * 65 + "\n")
    logger.info(f"ğŸš€ Ù†Ø¨Ø±Ø§Ø³ v3 ÙŠØ¹Ù…Ù„ | {len(hadith_db)} Ø­Ø¯ÙŠØ«")

    # â”€â”€ ØªØ´ØºÙŠÙ„ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± Ùˆ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹Ø§Ù‹ â”€â”€
    async with app:
        await app.start()
        await app.updater.start_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True,  # âœ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø© Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ‚Ù Ø§Ù„Ø¨ÙˆØª
        )

        # Ø´ØºÙ‘Ù„ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
        reminder_task = asyncio.create_task(
            reminder_loop(app.bot, user_data_mgr, hadith_db)
        )
        try:
            # Ø§Ù†ØªØ¸Ø± Ø­ØªÙ‰ ÙŠØªÙˆÙ‚Ù Ø§Ù„Ø¨ÙˆØª (Ctrl+C)
            await asyncio.Event().wait()
        except (KeyboardInterrupt, asyncio.CancelledError):
            pass
        finally:
            reminder_task.cancel()
            try:
                await reminder_task
            except asyncio.CancelledError:
                pass
            await app.updater.stop()
            await app.stop()


def main() -> None:
    try:
        asyncio.run(_run_bot())
    except KeyboardInterrupt:
        logger.info("ğŸ›‘ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª")
    except Exception as exc:
        logger.error(f"âŒ Ø®Ø·Ø£ Ø­Ø±Ø¬: {exc}", exc_info=True)
        raise


if __name__ == "__main__":
    main()